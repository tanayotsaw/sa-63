// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/USER/app/ent/migrate"

	"github.com/USER/app/ent/lessonplan"
	"github.com/USER/app/ent/section"
	"github.com/USER/app/ent/subject"
	"github.com/USER/app/ent/teacher"
	"github.com/USER/app/ent/user"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Lessonplan is the client for interacting with the Lessonplan builders.
	Lessonplan *LessonplanClient
	// Section is the client for interacting with the Section builders.
	Section *SectionClient
	// Subject is the client for interacting with the Subject builders.
	Subject *SubjectClient
	// Teacher is the client for interacting with the Teacher builders.
	Teacher *TeacherClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Lessonplan = NewLessonplanClient(c.config)
	c.Section = NewSectionClient(c.config)
	c.Subject = NewSubjectClient(c.config)
	c.Teacher = NewTeacherClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Lessonplan: NewLessonplanClient(cfg),
		Section:    NewSectionClient(cfg),
		Subject:    NewSubjectClient(cfg),
		Teacher:    NewTeacherClient(cfg),
		User:       NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:     cfg,
		Lessonplan: NewLessonplanClient(cfg),
		Section:    NewSectionClient(cfg),
		Subject:    NewSubjectClient(cfg),
		Teacher:    NewTeacherClient(cfg),
		User:       NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Lessonplan.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Lessonplan.Use(hooks...)
	c.Section.Use(hooks...)
	c.Subject.Use(hooks...)
	c.Teacher.Use(hooks...)
	c.User.Use(hooks...)
}

// LessonplanClient is a client for the Lessonplan schema.
type LessonplanClient struct {
	config
}

// NewLessonplanClient returns a client for the Lessonplan from the given config.
func NewLessonplanClient(c config) *LessonplanClient {
	return &LessonplanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lessonplan.Hooks(f(g(h())))`.
func (c *LessonplanClient) Use(hooks ...Hook) {
	c.hooks.Lessonplan = append(c.hooks.Lessonplan, hooks...)
}

// Create returns a create builder for Lessonplan.
func (c *LessonplanClient) Create() *LessonplanCreate {
	mutation := newLessonplanMutation(c.config, OpCreate)
	return &LessonplanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Lessonplan.
func (c *LessonplanClient) Update() *LessonplanUpdate {
	mutation := newLessonplanMutation(c.config, OpUpdate)
	return &LessonplanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LessonplanClient) UpdateOne(l *Lessonplan) *LessonplanUpdateOne {
	mutation := newLessonplanMutation(c.config, OpUpdateOne, withLessonplan(l))
	return &LessonplanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LessonplanClient) UpdateOneID(id int) *LessonplanUpdateOne {
	mutation := newLessonplanMutation(c.config, OpUpdateOne, withLessonplanID(id))
	return &LessonplanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lessonplan.
func (c *LessonplanClient) Delete() *LessonplanDelete {
	mutation := newLessonplanMutation(c.config, OpDelete)
	return &LessonplanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LessonplanClient) DeleteOne(l *Lessonplan) *LessonplanDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LessonplanClient) DeleteOneID(id int) *LessonplanDeleteOne {
	builder := c.Delete().Where(lessonplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LessonplanDeleteOne{builder}
}

// Create returns a query builder for Lessonplan.
func (c *LessonplanClient) Query() *LessonplanQuery {
	return &LessonplanQuery{config: c.config}
}

// Get returns a Lessonplan entity by its id.
func (c *LessonplanClient) Get(ctx context.Context, id int) (*Lessonplan, error) {
	return c.Query().Where(lessonplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LessonplanClient) GetX(ctx context.Context, id int) *Lessonplan {
	l, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return l
}

// QueryGroupID queries the Group_id edge of a Lessonplan.
func (c *LessonplanClient) QueryGroupID(l *Lessonplan) *SectionQuery {
	query := &SectionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lessonplan.Table, lessonplan.FieldID, id),
			sqlgraph.To(section.Table, section.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lessonplan.GroupIDTable, lessonplan.GroupIDColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseID queries the Course_ID edge of a Lessonplan.
func (c *LessonplanClient) QueryCourseID(l *Lessonplan) *SubjectQuery {
	query := &SubjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lessonplan.Table, lessonplan.FieldID, id),
			sqlgraph.To(subject.Table, subject.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lessonplan.CourseIDTable, lessonplan.CourseIDColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfessorID queries the Professor_ID edge of a Lessonplan.
func (c *LessonplanClient) QueryProfessorID(l *Lessonplan) *TeacherQuery {
	query := &TeacherQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lessonplan.Table, lessonplan.FieldID, id),
			sqlgraph.To(teacher.Table, teacher.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lessonplan.ProfessorIDTable, lessonplan.ProfessorIDColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LessonplanClient) Hooks() []Hook {
	return c.hooks.Lessonplan
}

// SectionClient is a client for the Section schema.
type SectionClient struct {
	config
}

// NewSectionClient returns a client for the Section from the given config.
func NewSectionClient(c config) *SectionClient {
	return &SectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `section.Hooks(f(g(h())))`.
func (c *SectionClient) Use(hooks ...Hook) {
	c.hooks.Section = append(c.hooks.Section, hooks...)
}

// Create returns a create builder for Section.
func (c *SectionClient) Create() *SectionCreate {
	mutation := newSectionMutation(c.config, OpCreate)
	return &SectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Section.
func (c *SectionClient) Update() *SectionUpdate {
	mutation := newSectionMutation(c.config, OpUpdate)
	return &SectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SectionClient) UpdateOne(s *Section) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSection(s))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SectionClient) UpdateOneID(id int) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSectionID(id))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Section.
func (c *SectionClient) Delete() *SectionDelete {
	mutation := newSectionMutation(c.config, OpDelete)
	return &SectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SectionClient) DeleteOne(s *Section) *SectionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SectionClient) DeleteOneID(id int) *SectionDeleteOne {
	builder := c.Delete().Where(section.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SectionDeleteOne{builder}
}

// Create returns a query builder for Section.
func (c *SectionClient) Query() *SectionQuery {
	return &SectionQuery{config: c.config}
}

// Get returns a Section entity by its id.
func (c *SectionClient) Get(ctx context.Context, id int) (*Section, error) {
	return c.Query().Where(section.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SectionClient) GetX(ctx context.Context, id int) *Section {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QuerySecID queries the sec_id edge of a Section.
func (c *SectionClient) QuerySecID(s *Section) *LessonplanQuery {
	query := &LessonplanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(section.Table, section.FieldID, id),
			sqlgraph.To(lessonplan.Table, lessonplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, section.SecIDTable, section.SecIDColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SectionClient) Hooks() []Hook {
	return c.hooks.Section
}

// SubjectClient is a client for the Subject schema.
type SubjectClient struct {
	config
}

// NewSubjectClient returns a client for the Subject from the given config.
func NewSubjectClient(c config) *SubjectClient {
	return &SubjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subject.Hooks(f(g(h())))`.
func (c *SubjectClient) Use(hooks ...Hook) {
	c.hooks.Subject = append(c.hooks.Subject, hooks...)
}

// Create returns a create builder for Subject.
func (c *SubjectClient) Create() *SubjectCreate {
	mutation := newSubjectMutation(c.config, OpCreate)
	return &SubjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Subject.
func (c *SubjectClient) Update() *SubjectUpdate {
	mutation := newSubjectMutation(c.config, OpUpdate)
	return &SubjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubjectClient) UpdateOne(s *Subject) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubject(s))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubjectClient) UpdateOneID(id int) *SubjectUpdateOne {
	mutation := newSubjectMutation(c.config, OpUpdateOne, withSubjectID(id))
	return &SubjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subject.
func (c *SubjectClient) Delete() *SubjectDelete {
	mutation := newSubjectMutation(c.config, OpDelete)
	return &SubjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SubjectClient) DeleteOne(s *Subject) *SubjectDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SubjectClient) DeleteOneID(id int) *SubjectDeleteOne {
	builder := c.Delete().Where(subject.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubjectDeleteOne{builder}
}

// Create returns a query builder for Subject.
func (c *SubjectClient) Query() *SubjectQuery {
	return &SubjectQuery{config: c.config}
}

// Get returns a Subject entity by its id.
func (c *SubjectClient) Get(ctx context.Context, id int) (*Subject, error) {
	return c.Query().Where(subject.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubjectClient) GetX(ctx context.Context, id int) *Subject {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryProfessorID queries the Professor_ID edge of a Subject.
func (c *SubjectClient) QueryProfessorID(s *Subject) *TeacherQuery {
	query := &TeacherQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subject.Table, subject.FieldID, id),
			sqlgraph.To(teacher.Table, teacher.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subject.ProfessorIDTable, subject.ProfessorIDColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubjectID queries the Subject_ID edge of a Subject.
func (c *SubjectClient) QuerySubjectID(s *Subject) *LessonplanQuery {
	query := &LessonplanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subject.Table, subject.FieldID, id),
			sqlgraph.To(lessonplan.Table, lessonplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subject.SubjectIDTable, subject.SubjectIDColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubjectClient) Hooks() []Hook {
	return c.hooks.Subject
}

// TeacherClient is a client for the Teacher schema.
type TeacherClient struct {
	config
}

// NewTeacherClient returns a client for the Teacher from the given config.
func NewTeacherClient(c config) *TeacherClient {
	return &TeacherClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `teacher.Hooks(f(g(h())))`.
func (c *TeacherClient) Use(hooks ...Hook) {
	c.hooks.Teacher = append(c.hooks.Teacher, hooks...)
}

// Create returns a create builder for Teacher.
func (c *TeacherClient) Create() *TeacherCreate {
	mutation := newTeacherMutation(c.config, OpCreate)
	return &TeacherCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Teacher.
func (c *TeacherClient) Update() *TeacherUpdate {
	mutation := newTeacherMutation(c.config, OpUpdate)
	return &TeacherUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeacherClient) UpdateOne(t *Teacher) *TeacherUpdateOne {
	mutation := newTeacherMutation(c.config, OpUpdateOne, withTeacher(t))
	return &TeacherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeacherClient) UpdateOneID(id int) *TeacherUpdateOne {
	mutation := newTeacherMutation(c.config, OpUpdateOne, withTeacherID(id))
	return &TeacherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Teacher.
func (c *TeacherClient) Delete() *TeacherDelete {
	mutation := newTeacherMutation(c.config, OpDelete)
	return &TeacherDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TeacherClient) DeleteOne(t *Teacher) *TeacherDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TeacherClient) DeleteOneID(id int) *TeacherDeleteOne {
	builder := c.Delete().Where(teacher.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeacherDeleteOne{builder}
}

// Create returns a query builder for Teacher.
func (c *TeacherClient) Query() *TeacherQuery {
	return &TeacherQuery{config: c.config}
}

// Get returns a Teacher entity by its id.
func (c *TeacherClient) Get(ctx context.Context, id int) (*Teacher, error) {
	return c.Query().Where(teacher.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeacherClient) GetX(ctx context.Context, id int) *Teacher {
	t, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return t
}

// QueryTeacherID queries the Teacher_ID edge of a Teacher.
func (c *TeacherClient) QueryTeacherID(t *Teacher) *SubjectQuery {
	query := &SubjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teacher.Table, teacher.FieldID, id),
			sqlgraph.To(subject.Table, subject.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, teacher.TeacherIDTable, teacher.TeacherIDColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeachersID queries the Teachers_ID edge of a Teacher.
func (c *TeacherClient) QueryTeachersID(t *Teacher) *LessonplanQuery {
	query := &LessonplanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teacher.Table, teacher.FieldID, id),
			sqlgraph.To(lessonplan.Table, lessonplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, teacher.TeachersIDTable, teacher.TeachersIDColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeacherClient) Hooks() []Hook {
	return c.hooks.Teacher
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Create returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	u, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return u
}

// QueryUserID queries the User_ID edge of a User.
func (c *UserClient) QueryUserID(u *User) *TeacherQuery {
	query := &TeacherQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(teacher.Table, teacher.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserIDTable, user.UserIDColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
