/// <reference types="node" />
import { Logger } from 'winston';
import express from 'express';
import Knex from 'knex';
import { Config } from '@backstage/config';
import Docker from 'dockerode';
import { Writable } from 'stream';
import { Entity } from '@backstage/catalog-model';

/**
 * The returned directory from the generator which is ready
 * to pass to the next stage of the TechDocs which is publishing
 */
declare type GeneratorRunResult = {
    resultDir: string;
};
/**
 * The values that the generator will receive. The directory of the
 * uncompiled documentation, with the values from the frontend. A dedicated log stream and a docker
 * client to run any generator on top of your directory.
 */
declare type GeneratorRunOptions = {
    directory: string;
    logStream?: Writable;
    dockerClient: Docker;
};
declare type GeneratorBase = {
    run(opts: GeneratorRunOptions): Promise<GeneratorRunResult>;
};
/**
 * List of supported generator options
 */
declare type SupportedGeneratorKey = 'techdocs' | string;
/**
 * The generator builder holds the generator ready for run time
 */
declare type GeneratorBuilder = {
    register(protocol: SupportedGeneratorKey, generator: GeneratorBase): void;
    get(entity: Entity): GeneratorBase;
};

declare class TechdocsGenerator implements GeneratorBase {
    private readonly logger;
    constructor(logger: Logger);
    run({ directory, logStream, dockerClient, }: GeneratorRunOptions): Promise<GeneratorRunResult>;
}

declare class Generators implements GeneratorBuilder {
    private generatorMap;
    register(generatorKey: SupportedGeneratorKey, generator: GeneratorBase): void;
    get(entity: Entity): GeneratorBase;
}

declare type PreparerBase = {
    /**
     * Given an Entity definition from the Service Catalog, go and prepare a directory
     * with contents from the location in temporary storage and return the path
     * @param entity The entity from the Service Catalog
     */
    prepare(entity: Entity, opts?: {
        logger: Logger;
    }): Promise<string>;
};
declare type PreparerBuilder = {
    register(protocol: RemoteProtocol, preparer: PreparerBase): void;
    get(entity: Entity): PreparerBase;
};
declare type RemoteProtocol = 'dir' | string;

declare class DirectoryPreparer implements PreparerBase {
    private readonly logger;
    constructor(logger: Logger);
    private resolveManagedByLocationToDir;
    prepare(entity: Entity): Promise<string>;
}

declare class GithubPreparer implements PreparerBase {
    private readonly logger;
    constructor(logger: Logger);
    prepare(entity: Entity): Promise<string>;
}

declare class Preparers implements PreparerBuilder {
    private preparerMap;
    register(protocol: RemoteProtocol, preparer: PreparerBase): void;
    get(entity: Entity): PreparerBase;
}

/**
 * Publisher is in charge of taking a folder created by
 * the builder, and pushing it to storage
 */
declare type PublisherBase = {
    /**
     *
     * @param opts object containing the entity from the service
     *             catalog, and the directory that has been generated
     */
    publish(opts: {
        entity: Entity;
        directory: string;
    }): Promise<{
        remoteUrl: string;
    }> | {
        remoteUrl: string;
    };
};

declare class LocalPublish implements PublisherBase {
    private readonly logger;
    constructor(logger: Logger);
    publish({ entity, directory, }: {
        entity: Entity;
        directory: string;
    }): Promise<{
        remoteUrl: string;
    }> | {
        remoteUrl: string;
    };
}

declare type RouterOptions = {
    preparers: PreparerBuilder;
    generators: GeneratorBuilder;
    publisher: PublisherBase;
    logger: Logger;
    database?: Knex;
    config: Config;
    dockerClient: Docker;
};
declare function createRouter({ preparers, generators, publisher, config, dockerClient, logger, }: RouterOptions): Promise<express.Router>;

export { DirectoryPreparer, GeneratorBuilder, Generators, GithubPreparer, LocalPublish, PreparerBuilder, Preparers, PublisherBase, TechdocsGenerator, createRouter };
