'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Router = _interopDefault(require('express-promise-router'));
var express2 = _interopDefault(require('express'));
var fetch = _interopDefault(require('node-fetch'));
var fs = _interopDefault(require('fs-extra'));
var path2 = _interopDefault(require('path'));
var os2 = _interopDefault(require('os'));
var stream = require('stream');
var backendCommon = require('@backstage/backend-common');
var parseGitUrl = _interopDefault(require('git-url-parse'));
var nodegit = require('nodegit');

function getGeneratorKey(entity) {
  if (!entity) {
    throw new Error("No entity provided");
  }
  return "techdocs";
}
async function runDockerContainer({
  imageName,
  args,
  logStream = new stream.PassThrough(),
  docsDir,
  resultDir,
  dockerClient,
  createOptions
}) {
  await new Promise((resolve, reject) => {
    dockerClient.pull(imageName, {}, (err, stream2) => {
      if (err)
        return reject(err);
      stream2.pipe(logStream, {end: false});
      stream2.on("end", () => resolve());
      stream2.on("error", (error2) => reject(error2));
      return void 0;
    });
  });
  const [{Error: error, StatusCode: statusCode}] = await dockerClient.run(imageName, args, logStream, {
    Volumes: {
      "/content": {},
      "/result": {}
    },
    WorkingDir: "/content",
    HostConfig: {
      Binds: [`${docsDir}:/content`, `${resultDir}:/result`]
    },
    ...createOptions
  });
  if (error) {
    throw new Error(`Docker failed to run with the following error message: ${error}`);
  }
  if (statusCode !== 0) {
    throw new Error(`Docker container returned a non-zero exit code (${statusCode})`);
  }
  return {error, statusCode};
}

class TechdocsGenerator {
  constructor(logger) {
    this.logger = logger;
  }
  async run({
    directory,
    logStream,
    dockerClient
  }) {
    const tmpdirPath = os2.tmpdir();
    const tmpdirResolvedPath = fs.realpathSync(tmpdirPath);
    const resultDir = fs.mkdtempSync(path2.join(tmpdirResolvedPath, "techdocs-tmp-"));
    try {
      await runDockerContainer({
        imageName: "spotify/techdocs",
        args: ["build", "-d", "/result"],
        logStream,
        docsDir: directory,
        resultDir,
        dockerClient
      });
      this.logger.info(`[TechDocs]: Successfully generated docs from ${directory} into ${resultDir}`);
    } catch (error) {
      this.logger.debug(`[TechDocs]: Failed to generate docs from ${directory} into ${resultDir}`);
      throw new Error(`Failed to generate docs from ${directory} into ${resultDir} with error ${error.message}`);
    }
    return {resultDir};
  }
}

class Generators {
  constructor() {
    this.generatorMap = new Map();
  }
  register(generatorKey, generator) {
    this.generatorMap.set(generatorKey, generator);
  }
  get(entity) {
    const generatorKey = getGeneratorKey(entity);
    const generator = this.generatorMap.get(generatorKey);
    if (!generator) {
      throw new Error(`No generator registered for entity: "${generatorKey}"`);
    }
    return generator;
  }
}

const parseReferenceAnnotation = (annotationName, entity) => {
  var _a;
  const annotation = (_a = entity.metadata.annotations) == null ? void 0 : _a[annotationName];
  if (!annotation) {
    throw new backendCommon.InputError(`No location annotation provided in entity: ${entity.metadata.name}`);
  }
  const [type, target] = annotation.split(/:(.+)/);
  if (!type || !target) {
    throw new backendCommon.InputError(`Failure to parse either protocol or location for entity: ${entity.metadata.name}`);
  }
  return {
    type,
    target
  };
};
const checkoutGitRepository = async (repoUrl) => {
  const parsedGitLocation = parseGitUrl(repoUrl);
  const repositoryTmpPath = path2.join(fs.realpathSync(os2.tmpdir()), "backstage-repo", parsedGitLocation.source, parsedGitLocation.owner, parsedGitLocation.name, parsedGitLocation.ref);
  if (fs.existsSync(repositoryTmpPath)) {
    const repository = await nodegit.Repository.open(repositoryTmpPath);
    const currentBranchName = (await repository.getCurrentBranch()).shorthand();
    await repository.mergeBranches(currentBranchName, `origin/${currentBranchName}`);
    return repositoryTmpPath;
  }
  const repositoryCheckoutUrl = parsedGitLocation.toString("https");
  fs.mkdirSync(repositoryTmpPath, {recursive: true});
  await nodegit.Clone.clone(repositoryCheckoutUrl, repositoryTmpPath, {});
  return repositoryTmpPath;
};

class DirectoryPreparer {
  constructor(logger) {
    this.logger = logger;
  }
  async resolveManagedByLocationToDir(entity) {
    const {type, target} = parseReferenceAnnotation("backstage.io/managed-by-location", entity);
    this.logger.debug(`[TechDocs] Building docs for entity with type 'dir' and managed-by-location '${type}'`);
    switch (type) {
      case "github": {
        const parsedGitLocation = parseGitUrl(target);
        const repoLocation = await checkoutGitRepository(target);
        return path2.dirname(path2.join(repoLocation, parsedGitLocation.filepath));
      }
      case "file":
        return path2.dirname(target);
      default:
        throw new backendCommon.InputError(`Unable to resolve location type ${type}`);
    }
  }
  async prepare(entity) {
    const {target} = parseReferenceAnnotation("backstage.io/techdocs-ref", entity);
    const managedByLocationDirectory = await this.resolveManagedByLocationToDir(entity);
    return new Promise((resolve) => {
      resolve(path2.resolve(managedByLocationDirectory, target));
    });
  }
}

class GithubPreparer {
  constructor(logger) {
    this.logger = logger;
  }
  async prepare(entity) {
    const {type, target} = parseReferenceAnnotation("backstage.io/techdocs-ref", entity);
    if (type !== "github") {
      throw new backendCommon.InputError(`Wrong target type: ${type}, should be 'github'`);
    }
    try {
      const repoPath = await checkoutGitRepository(target);
      const parsedGitLocation = parseGitUrl(target);
      return path2.join(repoPath, parsedGitLocation.filepath);
    } catch (error) {
      this.logger.debug(`Repo checkout failed with error ${error.message}`);
      throw error;
    }
  }
}

class Preparers {
  constructor() {
    this.preparerMap = new Map();
  }
  register(protocol, preparer) {
    this.preparerMap.set(protocol, preparer);
  }
  get(entity) {
    const {type} = parseReferenceAnnotation("backstage.io/techdocs-ref", entity);
    const preparer = this.preparerMap.get(type);
    if (!preparer) {
      throw new Error(`No preparer registered for type: "${type}"`);
    }
    return preparer;
  }
}

class LocalPublish {
  constructor(logger) {
    this.logger = logger;
  }
  publish({
    entity,
    directory
  }) {
    var _a;
    const entityNamespace = (_a = entity.metadata.namespace) != null ? _a : "default";
    const publishDir = backendCommon.resolvePackagePath("@backstage/plugin-techdocs-backend", "static/docs", entity.kind, entityNamespace, entity.metadata.name);
    if (!fs.existsSync(publishDir)) {
      this.logger.info(`[TechDocs]: Could not find ${publishDir}, creates the directory.`);
      fs.mkdirSync(publishDir, {recursive: true});
    }
    return new Promise((resolve, reject) => {
      fs.copy(directory, publishDir, (err) => {
        if (err) {
          this.logger.debug(`[TechDocs]: Failed to copy docs from ${directory} to ${publishDir}`);
          reject(err);
        }
        resolve({
          remoteUrl: `http://localhost:7000/techdocs/static/docs/${entity.metadata.name}`
        });
      });
    });
  }
}

const staticDocsDir = backendCommon.resolvePackagePath("@backstage/plugin-techdocs-backend", "static/docs");
async function createRouter({
  preparers,
  generators,
  publisher,
  config: config2,
  dockerClient,
  logger
}) {
  const router = Router();
  const getEntityId = (entity) => {
    var _a;
    return `${entity.kind}:${(_a = entity.metadata.namespace) != null ? _a : ""}:${entity.metadata.name}`;
  };
  const buildDocsForEntity = async (entity) => {
    const preparer = preparers.get(entity);
    const generator = generators.get(entity);
    logger.info(`[TechDocs] Running preparer on entity ${getEntityId(entity)}`);
    const preparedDir = await preparer.prepare(entity);
    logger.info(`[TechDocs] Running generator on entity ${getEntityId(entity)}`);
    const {resultDir} = await generator.run({
      directory: preparedDir,
      dockerClient
    });
    logger.info(`[TechDocs] Running publisher on entity ${getEntityId(entity)}`);
    await publisher.publish({
      entity,
      directory: resultDir
    });
  };
  router.get("/", async (_, res) => {
    res.status(200).send("Hello TechDocs Backend");
  });
  router.get("/buildall", async (_, res) => {
    const baseUrl = config2.getString("backend.baseUrl");
    const entitiesResponse = await (await fetch(`${baseUrl}/catalog/entities`)).json();
    const entitiesWithDocs = entitiesResponse.filter((entity) => {
      var _a;
      return (_a = entity.metadata.annotations) == null ? void 0 : _a["backstage.io/techdocs-ref"];
    });
    entitiesWithDocs.forEach(async (entity) => {
      await buildDocsForEntity(entity);
    });
    res.send("Successfully generated documentation");
  });
  if (publisher instanceof LocalPublish) {
    router.use("/static/docs/", express2.static(staticDocsDir));
    router.use("/static/docs/:kind/:namespace/:name", async (req, res, next) => {
      const baseUrl = config2.getString("backend.baseUrl");
      const {kind, namespace, name} = req.params;
      const entityResponse = await fetch(`${baseUrl}/catalog/entities/by-name/${kind}/${namespace}/${name}`);
      if (!entityResponse.ok)
        next();
      const entity = await entityResponse.json();
      await buildDocsForEntity(entity);
      res.redirect(req.originalUrl);
    });
  }
  return router;
}

exports.DirectoryPreparer = DirectoryPreparer;
exports.Generators = Generators;
exports.GithubPreparer = GithubPreparer;
exports.LocalPublish = LocalPublish;
exports.Preparers = Preparers;
exports.TechdocsGenerator = TechdocsGenerator;
exports.createRouter = createRouter;
