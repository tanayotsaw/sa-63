import { JsonObject, JsonValue } from '@backstage/config';
import { JSONSchema7 } from 'json-schema';
import { Schema, ObjectSchema } from 'yup';

/**
 * The format envelope that's common to all versions/kinds of entity.
 *
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
 */
declare type Entity = {
    /**
     * The version of specification format for this particular entity that
     * this is written against.
     */
    apiVersion: string;
    /**
     * The high level entity type being described.
     */
    kind: string;
    /**
     * Metadata related to the entity.
     */
    metadata: EntityMeta;
    /**
     * The specification data describing the entity itself.
     */
    spec?: JsonObject;
};
/**
 * Metadata fields common to all versions/kinds of entity.
 *
 * @see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
 */
declare type EntityMeta = JsonObject & {
    /**
     * A globally unique ID for the entity.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations. The field can (optionally) be specified when performing
     * update or delete operations, but the server is free to reject requests
     * that do so in such a way that it breaks semantics.
     */
    uid?: string;
    /**
     * An opaque string that changes for each update operation to any part of
     * the entity, including metadata.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations. The field can (optionally) be specified when performing
     * update or delete operations, and the server will then reject the
     * operation if it does not match the current stored value.
     */
    etag?: string;
    /**
     * A positive nonzero number that indicates the current generation of data
     * for this entity; the value is incremented each time the spec changes.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations.
     */
    generation?: number;
    /**
     * The name of the entity.
     *
     * Must be uniqe within the catalog at any given point in time, for any
     * given namespace + kind pair.
     */
    name: string;
    /**
     * The namespace that the entity belongs to.
     */
    namespace?: string;
    /**
     * A short (typically relatively few words, on one line) description of the
     * entity.
     */
    description?: string;
    /**
     * Key/value pairs of identifying information attached to the entity.
     */
    labels?: Record<string, string>;
    /**
     * Key/value pairs of non-identifying auxiliary information attached to the
     * entity.
     */
    annotations?: Record<string, string>;
    /**
     * A list of single-valued strings, to for example classify catalog entities in
     * various ways.
     */
    tags?: string[];
};
/**
 * The keys of EntityMeta that are auto-generated.
 */
declare const entityMetaGeneratedFields: readonly ["uid", "etag", "generation"];

/**
 * A policy for validation or mutation to be applied to entities as they are
 * entering the system.
 */
declare type EntityPolicy = {
    /**
     * Applies validation or mutation on an entity.
     *
     * @param entity The entity, as validated/mutated so far in the policy tree
     * @returns The incoming entity, or a mutated version of the same
     * @throws An error if the entity should be rejected
     */
    enforce(entity: Entity): Promise<Entity>;
};
declare type JSONSchema = JSONSchema7 & {
    [key in string]?: JsonValue;
};

/**
 * Sets a default namespace if none was set.
 */
declare class DefaultNamespaceEntityPolicy implements EntityPolicy {
    private readonly namespace;
    constructor(namespace?: string);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Contains various helper validation and normalization functions that can be
 * composed to form a Validator.
 */
declare class CommonValidatorFunctions {
    /**
     * Checks that the value is on the form <suffix> or <prefix><separator><suffix>, and validates
     * those parts separately.
     *
     * @param value The value to check
     * @param separator The separator between parts
     * @param isValidPrefix Checks that the part before the separator is valid, if present
     * @param isValidSuffix Checks that the part after the separator (or the entire value if there is no separator) is valid
     */
    static isValidPrefixAndOrSuffix(value: any, separator: string, isValidPrefix: (value: string) => boolean, isValidSuffix: (value: string) => boolean): boolean;
    /**
     * Checks that the value can be safely transferred as JSON.
     *
     * @param value The value to check
     */
    static isJsonSafe(value: any): boolean;
    /**
     * Checks that the value is a valid DNS subdomain name.
     *
     * @param value The value to check
     * @see https://tools.ietf.org/html/rfc1123
     */
    static isValidDnsSubdomain(value: any): boolean;
    /**
     * Checks that the value is a valid DNS label.
     *
     * @param value The value to check
     * @see https://tools.ietf.org/html/rfc1123
     */
    static isValidDnsLabel(value: any): boolean;
    /**
     * Normalizes by keeping only a-z, A-Z, and 0-9; and converts to lowercase.
     *
     * @param value The value to normalize
     */
    static normalizeToLowercaseAlphanum(value: string): string;
}

/**
 * Contains validation functions that match the Kubernetes spec, usable to
 * build a catalog that is compatible with those rule sets.
 *
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/names/
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
 */
declare class KubernetesValidatorFunctions {
    static isValidApiVersion(value: any): boolean;
    static isValidKind(value: any): boolean;
    static isValidObjectName(value: any): boolean;
    static isValidNamespace(value: any): boolean;
    static isValidLabelKey(value: any): boolean;
    static isValidLabelValue(value: any): boolean;
    static isValidAnnotationKey(value: any): boolean;
    static isValidAnnotationValue(value: any): boolean;
}

declare type Validators = {
    isValidApiVersion(value: any): boolean;
    isValidKind(value: any): boolean;
    isValidEntityName(value: any): boolean;
    isValidNamespace(value: any): boolean;
    normalizeEntityName(value: string): string;
    isValidLabelKey(value: any): boolean;
    isValidLabelValue(value: any): boolean;
    isValidAnnotationKey(value: any): boolean;
    isValidAnnotationValue(value: any): boolean;
    isValidTag(value: any): boolean;
};

declare function makeValidator(overrides?: Partial<Validators>): Validators;

/**
 * Ensures that the format of individual fields of the entity envelope
 * is valid.
 *
 * This does not take into account machine generated fields such as uid, etag
 * and generation.
 */
declare class FieldFormatEntityPolicy implements EntityPolicy {
    private readonly validators;
    constructor(validators?: Validators);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Ensures that there are no foreign root fields in the entity.
 */
declare class NoForeignRootFieldsEntityPolicy implements EntityPolicy {
    private readonly knownFields;
    constructor(knownFields?: string[]);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Ensures that fields are not given certain reserved names.
 */
declare class ReservedFieldsEntityPolicy implements EntityPolicy {
    private readonly reservedFields;
    constructor(fields?: string[]);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Ensures that the entity spec is valid according to a schema.
 *
 * This should be the first policy in the list, to ensure that other downstream
 * policies can work with a structure that is at least valid in therms of the
 * typescript type.
 */
declare class SchemaValidEntityPolicy implements EntityPolicy {
    private readonly schema;
    constructor(schema?: Schema<Entity>);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Generates a new random UID for an entity.
 *
 * @returns A string with enough randomness to uniquely identify an entity
 */
declare function generateEntityUid(): string;
/**
 * Generates a new random Etag for an entity.
 *
 * @returns A string with enough randomness to uniquely identify an entity
 *          revision
 */
declare function generateEntityEtag(): string;
/**
 * Checks whether there are any significant changes going from the previous to
 * the next version of this entity.
 *
 * Significance, in this case, means that we do not compare generated fields
 * such as uid, etag and generation, and we only check that no new annotations
 * are added or existing annotations were changed (since they are effectively
 * merged when doing updates).
 *
 * @param previous The old state of the entity
 * @param next The new state of the entity
 */
declare function entityHasChanges(previous: Entity, next: Entity): boolean;
/**
 * Takes an old revision of an entity and a new desired state, and merges
 * them into a complete new state.
 *
 * The previous revision is expected to be a complete model loaded from the
 * catalog, including the uid, etag and generation fields.
 *
 * @param previous The old state of the entity
 * @param next The new state of the entity
 * @returns An entity with the merged state of both
 */
declare function generateUpdatedEntity(previous: Entity, next: Entity): Entity;

declare class EntityPolicies implements EntityPolicy {
    private readonly policy;
    static defaultPolicies(): EntityPolicy;
    static allOf(policies: EntityPolicy[]): EntityPolicy;
    static anyOf(policies: EntityPolicy[]): EntityPolicy;
    constructor(policy?: EntityPolicy);
    enforce(entity: Entity): Promise<Entity>;
}

declare const API_VERSION: readonly ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
declare const KIND: "Component";
interface ComponentEntityV1alpha1 extends Entity {
    apiVersion: typeof API_VERSION[number];
    kind: typeof KIND;
    spec: {
        type: string;
        lifecycle: string;
        owner: string;
        implementsApis?: string[];
    };
}
declare class ComponentEntityV1alpha1Policy implements EntityPolicy {
    private schema;
    constructor();
    enforce(envelope: Entity): Promise<Entity>;
}

declare const API_VERSION$1: readonly ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
declare const KIND$1: "Group";
interface GroupEntityV1alpha1 extends Entity {
    apiVersion: typeof API_VERSION$1[number];
    kind: typeof KIND$1;
    spec: {
        type: string;
        parent?: string;
        ancestors: string[];
        children: string[];
        descendants: string[];
    };
}
declare class GroupEntityV1alpha1Policy implements EntityPolicy {
    private schema;
    constructor();
    enforce(envelope: Entity): Promise<Entity>;
}

declare const API_VERSION$2: readonly ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
declare const KIND$2: "Location";
interface LocationEntityV1alpha1 extends Entity {
    apiVersion: typeof API_VERSION$2[number];
    kind: typeof KIND$2;
    spec: {
        type: string;
        target?: string;
        targets?: string[];
    };
}
declare class LocationEntityV1alpha1Policy implements EntityPolicy {
    private schema;
    constructor();
    enforce(envelope: Entity): Promise<Entity>;
}

declare const API_VERSION$3: readonly ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
declare const KIND$3: "Template";
interface TemplateEntityV1alpha1 extends Entity {
    apiVersion: typeof API_VERSION$3[number];
    kind: typeof KIND$3;
    spec: {
        type: string;
        templater: string;
        path?: string;
        schema: JSONSchema;
    };
}
declare class TemplateEntityV1alpha1Policy implements EntityPolicy {
    private schema;
    constructor();
    enforce(envelope: Entity): Promise<Entity>;
}

declare const API_VERSION$4: readonly ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
declare const KIND$4: "API";
interface ApiEntityV1alpha1 extends Entity {
    apiVersion: typeof API_VERSION$4[number];
    kind: typeof KIND$4;
    spec: {
        type: string;
        definition: string;
    };
}
declare class ApiEntityV1alpha1Policy implements EntityPolicy {
    private schema;
    constructor();
    enforce(envelope: Entity): Promise<Entity>;
}

declare type LocationSpec = {
    type: string;
    target: string;
};
declare type Location = {
    id: string;
} & LocationSpec;

declare const locationSpecSchema: ObjectSchema<LocationSpec>;
declare const locationSchema: ObjectSchema<Location>;

declare const LOCATION_ANNOTATION = "backstage.io/managed-by-location";

export { ApiEntityV1alpha1 as ApiEntity, ApiEntityV1alpha1, ApiEntityV1alpha1Policy, CommonValidatorFunctions, ComponentEntityV1alpha1 as ComponentEntity, ComponentEntityV1alpha1, ComponentEntityV1alpha1Policy, DefaultNamespaceEntityPolicy, Entity, EntityMeta, EntityPolicies, EntityPolicy, FieldFormatEntityPolicy, GroupEntityV1alpha1 as GroupEntity, GroupEntityV1alpha1, GroupEntityV1alpha1Policy, JSONSchema, KubernetesValidatorFunctions, LOCATION_ANNOTATION, Location, LocationEntityV1alpha1 as LocationEntity, LocationEntityV1alpha1, LocationEntityV1alpha1Policy, LocationSpec, NoForeignRootFieldsEntityPolicy, ReservedFieldsEntityPolicy, SchemaValidEntityPolicy, TemplateEntityV1alpha1 as TemplateEntity, TemplateEntityV1alpha1, TemplateEntityV1alpha1Policy, Validators, entityHasChanges, entityMetaGeneratedFields, generateEntityEtag, generateEntityUid, generateUpdatedEntity, locationSchema, locationSpecSchema, makeValidator };
