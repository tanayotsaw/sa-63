'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var lodash2 = _interopDefault(require('lodash'));
var yup = require('yup');
var uuid = require('uuid');

const entityMetaGeneratedFields = ["uid", "etag", "generation"];

class DefaultNamespaceEntityPolicy {
  constructor(namespace = "default") {
    this.namespace = namespace;
  }
  async enforce(entity) {
    if (entity.metadata.namespace) {
      return entity;
    }
    return lodash2.merge({metadata: {namespace: this.namespace}}, entity);
  }
}

class CommonValidatorFunctions {
  static isValidPrefixAndOrSuffix(value, separator, isValidPrefix, isValidSuffix) {
    if (typeof value !== "string") {
      return false;
    }
    const parts = value.split(separator);
    if (parts.length === 1) {
      return isValidSuffix(parts[0]);
    } else if (parts.length === 2) {
      return isValidPrefix(parts[0]) && isValidSuffix(parts[1]);
    }
    return false;
  }
  static isJsonSafe(value) {
    try {
      return lodash2.isEqual(value, JSON.parse(JSON.stringify(value)));
    } catch {
      return false;
    }
  }
  static isValidDnsSubdomain(value) {
    return typeof value === "string" && value.length >= 1 && value.length <= 253 && value.split(".").every(CommonValidatorFunctions.isValidDnsLabel);
  }
  static isValidDnsLabel(value) {
    return typeof value === "string" && value.length >= 1 && value.length <= 63 && /^[a-z0-9]+(\-[a-z0-9]+)*$/.test(value);
  }
  static normalizeToLowercaseAlphanum(value) {
    return value.split("").filter((x) => /[a-zA-Z0-9]/.test(x)).join("").toLowerCase();
  }
}

class KubernetesValidatorFunctions {
  static isValidApiVersion(value) {
    return CommonValidatorFunctions.isValidPrefixAndOrSuffix(value, "/", CommonValidatorFunctions.isValidDnsSubdomain, (n) => n.length >= 1 && n.length <= 63 && /^[a-z0-9A-Z]+$/.test(n));
  }
  static isValidKind(value) {
    return typeof value === "string" && value.length >= 1 && value.length <= 63 && /^[a-zA-Z][a-z0-9A-Z]*$/.test(value);
  }
  static isValidObjectName(value) {
    return typeof value === "string" && value.length >= 1 && value.length <= 63 && /^[a-z0-9A-Z]+([-_.][a-z0-9A-Z]+)*$/.test(value);
  }
  static isValidNamespace(value) {
    return CommonValidatorFunctions.isValidDnsLabel(value);
  }
  static isValidLabelKey(value) {
    return CommonValidatorFunctions.isValidPrefixAndOrSuffix(value, "/", CommonValidatorFunctions.isValidDnsSubdomain, KubernetesValidatorFunctions.isValidObjectName);
  }
  static isValidLabelValue(value) {
    return value === "" || KubernetesValidatorFunctions.isValidObjectName(value);
  }
  static isValidAnnotationKey(value) {
    return CommonValidatorFunctions.isValidPrefixAndOrSuffix(value, "/", CommonValidatorFunctions.isValidDnsSubdomain, KubernetesValidatorFunctions.isValidObjectName);
  }
  static isValidAnnotationValue(value) {
    return typeof value === "string";
  }
}

const defaultValidators = {
  isValidApiVersion: KubernetesValidatorFunctions.isValidApiVersion,
  isValidKind: KubernetesValidatorFunctions.isValidKind,
  isValidEntityName: KubernetesValidatorFunctions.isValidObjectName,
  isValidNamespace: KubernetesValidatorFunctions.isValidNamespace,
  normalizeEntityName: CommonValidatorFunctions.normalizeToLowercaseAlphanum,
  isValidLabelKey: KubernetesValidatorFunctions.isValidLabelKey,
  isValidLabelValue: KubernetesValidatorFunctions.isValidLabelValue,
  isValidAnnotationKey: KubernetesValidatorFunctions.isValidAnnotationKey,
  isValidAnnotationValue: KubernetesValidatorFunctions.isValidAnnotationValue,
  isValidTag: CommonValidatorFunctions.isValidDnsLabel
};
function makeValidator(overrides = {}) {
  return {
    ...defaultValidators,
    ...overrides
  };
}

class FieldFormatEntityPolicy {
  constructor(validators = makeValidator()) {
    this.validators = validators;
  }
  async enforce(entity) {
    var _a, _b, _c;
    function require2(field, value, validator) {
      if (value === void 0 || value === null) {
        throw new Error(`${field} must have a value`);
      }
      let isValid;
      try {
        isValid = validator(value);
      } catch (e) {
        throw new Error(`${field} could not be validated, ${e}`);
      }
      if (!isValid) {
        throw new Error(`${field} "${value}" is not valid`);
      }
    }
    function optional(field, value, validator) {
      return value === void 0 || require2(field, value, validator);
    }
    require2("apiVersion", entity.apiVersion, this.validators.isValidApiVersion);
    require2("kind", entity.kind, this.validators.isValidKind);
    require2("metadata.name", entity.metadata.name, this.validators.isValidEntityName);
    optional("metadata.namespace", entity.metadata.namespace, this.validators.isValidNamespace);
    for (const [k, v] of Object.entries((_a = entity.metadata.labels) != null ? _a : [])) {
      require2(`labels.${k}`, k, this.validators.isValidLabelKey);
      require2(`labels.${k}`, v, this.validators.isValidLabelValue);
    }
    for (const [k, v] of Object.entries((_b = entity.metadata.annotations) != null ? _b : [])) {
      require2(`annotations.${k}`, k, this.validators.isValidAnnotationKey);
      require2(`annotations.${k}`, v, this.validators.isValidAnnotationValue);
    }
    const tags = (_c = entity.metadata.tags) != null ? _c : [];
    for (let i = 0; i < tags.length; ++i) {
      require2(`tags.${i}`, tags[i], this.validators.isValidTag);
    }
    return entity;
  }
}

const defaultKnownFields = ["apiVersion", "kind", "metadata", "spec"];
class NoForeignRootFieldsEntityPolicy {
  constructor(knownFields = defaultKnownFields) {
    this.knownFields = knownFields;
  }
  async enforce(entity) {
    for (const field of Object.keys(entity)) {
      if (!this.knownFields.includes(field)) {
        throw new Error(`Unknown field ${field}`);
      }
    }
    return entity;
  }
}

const DEFAULT_RESERVED_ENTITY_FIELDS = [
  "apiVersion",
  "kind",
  "spec",
  "metadata.uid",
  "metadata.etag",
  "metadata.generation",
  "metadata.name",
  "metadata.namespace",
  "metadata.description",
  "metadata.labels",
  "metadata.annotations",
  "metadata.tags",
  "spec.lifecycle",
  "spec.owner"
];
class ReservedFieldsEntityPolicy {
  constructor(fields) {
    this.reservedFields = [
      ...fields != null ? fields : [],
      ...DEFAULT_RESERVED_ENTITY_FIELDS
    ];
  }
  async enforce(entity) {
    var _a, _b, _c;
    for (const path of this.reservedFields) {
      const [where, name] = path.includes(".") ? path.split(".") : [void 0, path];
      if (where !== "metadata" && entity.metadata.hasOwnProperty(name)) {
        throw new Error(`The metadata may not contain the field ${name}, because it has reserved meaning`);
      }
      if (where !== "spec" && ((_a = entity.spec) == null ? void 0 : _a.hasOwnProperty(name))) {
        throw new Error(`The spec may not contain the field ${name}, because it has reserved meaning`);
      }
      if (where !== "labels" && ((_b = entity.metadata.labels) == null ? void 0 : _b.hasOwnProperty(name))) {
        throw new Error(`A label may not have the field ${name}, because it has reserved meaning`);
      }
      if (where !== "annotations" && ((_c = entity.metadata.annotations) == null ? void 0 : _c.hasOwnProperty(name))) {
        throw new Error(`An annotation may not have the field ${name}, because it has reserved meaning`);
      }
    }
    return entity;
  }
}

const DEFAULT_ENTITY_SCHEMA = yup.object({
  apiVersion: yup.string().required(),
  kind: yup.string().required(),
  metadata: yup.object({
    uid: yup.string().notRequired().min(1),
    etag: yup.string().notRequired().min(1),
    generation: yup.number().notRequired().integer().min(1),
    name: yup.string().required(),
    namespace: yup.string().notRequired(),
    description: yup.string().notRequired(),
    labels: yup.object().notRequired(),
    annotations: yup.object().notRequired(),
    tags: yup.array().notRequired()
  }).required(),
  spec: yup.object({}).notRequired()
});
class SchemaValidEntityPolicy {
  constructor(schema = DEFAULT_ENTITY_SCHEMA) {
    this.schema = schema;
  }
  async enforce(entity) {
    try {
      return await this.schema.validate(entity, {strict: true});
    } catch (e) {
      throw new Error(`Malformed envelope, ${e}`);
    }
  }
}

function generateEntityUid() {
  return uuid.v4();
}
function generateEntityEtag() {
  return Buffer.from(uuid.v4(), "utf8").toString("base64").replace(/[^\w]/g, "");
}
function entityHasChanges(previous, next) {
  if (entityHasAnnotationChanges(previous, next)) {
    return true;
  }
  const e1 = lodash2.cloneDeep(previous);
  const e2 = lodash2.cloneDeep(next);
  if (!e1.metadata.labels) {
    e1.metadata.labels = {};
  }
  if (!e2.metadata.labels) {
    e2.metadata.labels = {};
  }
  delete e1.metadata.uid;
  delete e1.metadata.etag;
  delete e1.metadata.generation;
  delete e2.metadata.uid;
  delete e2.metadata.etag;
  delete e2.metadata.generation;
  delete e1.metadata.annotations;
  delete e2.metadata.annotations;
  return !lodash2.isEqual(e1, e2);
}
function generateUpdatedEntity(previous, next) {
  const {uid, etag, generation} = previous.metadata;
  if (!uid || !etag || !generation) {
    throw new Error("Previous entity must have uid, etag and generation");
  }
  const result = lodash2.cloneDeep(next);
  if (previous.metadata.annotations) {
    next.metadata.annotations = {
      ...previous.metadata.annotations,
      ...next.metadata.annotations
    };
  }
  const bumpEtag = entityHasChanges(previous, result);
  const bumpGeneration = !lodash2.isEqual(previous.spec, result.spec);
  result.metadata.uid = uid;
  result.metadata.etag = bumpEtag ? generateEntityEtag() : etag;
  result.metadata.generation = bumpGeneration ? generation + 1 : generation;
  return result;
}
function entityHasAnnotationChanges(previous, next) {
  if (next.metadata.annotations) {
    if (!previous.metadata.annotations) {
      return true;
    }
    if (!lodash2.isEqual(next.metadata.annotations, lodash2.pick(previous.metadata.annotations, Object.keys(next.metadata.annotations)))) {
      return true;
    }
  }
  return false;
}

const API_VERSION = ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
const KIND = "Component";
class ComponentEntityV1alpha1Policy {
  constructor() {
    this.schema = yup.object({
      apiVersion: yup.string().required().oneOf(API_VERSION),
      kind: yup.string().required().equals([KIND]),
      spec: yup.object({
        type: yup.string().required().min(1),
        lifecycle: yup.string().required().min(1),
        owner: yup.string().required().min(1),
        implementsApis: yup.array(yup.string()).notRequired()
      }).required()
    });
  }
  async enforce(envelope) {
    return await this.schema.validate(envelope, {strict: true});
  }
}

const API_VERSION$1 = ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
const KIND$1 = "Group";
class GroupEntityV1alpha1Policy {
  constructor() {
    this.schema = yup.object({
      apiVersion: yup.string().required().oneOf(API_VERSION$1),
      kind: yup.string().required().equals([KIND$1]),
      spec: yup.object({
        type: yup.string().required().min(1),
        parent: yup.string().notRequired().min(1),
        ancestors: yup.array(yup.string()).required(),
        children: yup.array(yup.string()).required(),
        descendants: yup.array(yup.string()).required()
      }).required()
    });
  }
  async enforce(envelope) {
    return await this.schema.validate(envelope, {strict: true});
  }
}

const API_VERSION$2 = ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
const KIND$2 = "Location";
class LocationEntityV1alpha1Policy {
  constructor() {
    this.schema = yup.object({
      apiVersion: yup.string().required().oneOf(API_VERSION$2),
      kind: yup.string().required().equals([KIND$2]),
      spec: yup.object({
        type: yup.string().required().min(1),
        target: yup.string().notRequired().min(1),
        targets: yup.array(yup.string()).notRequired()
      }).required()
    });
  }
  async enforce(envelope) {
    return await this.schema.validate(envelope, {strict: true});
  }
}

const API_VERSION$3 = ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
const KIND$3 = "Template";
class TemplateEntityV1alpha1Policy {
  constructor() {
    this.schema = yup.object({
      apiVersion: yup.string().required().oneOf(API_VERSION$3),
      kind: yup.string().required().equals([KIND$3]),
      spec: yup.object({
        type: yup.string().required().min(1),
        path: yup.string(),
        schema: yup.object().required(),
        templater: yup.string().required()
      }).required()
    });
  }
  async enforce(envelope) {
    return await this.schema.validate(envelope, {strict: true});
  }
}

const API_VERSION$4 = ["backstage.io/v1alpha1", "backstage.io/v1beta1"];
const KIND$4 = "API";
class ApiEntityV1alpha1Policy {
  constructor() {
    this.schema = yup.object({
      apiVersion: yup.string().required().oneOf(API_VERSION$4),
      kind: yup.string().required().equals([KIND$4]),
      spec: yup.object({
        type: yup.string().required().min(1),
        definition: yup.string().required().min(1)
      }).required()
    });
  }
  async enforce(envelope) {
    return await this.schema.validate(envelope, {strict: true});
  }
}

class AllEntityPolicies {
  constructor(policies) {
    this.policies = policies;
  }
  async enforce(entity2) {
    let result = entity2;
    for (const policy of this.policies) {
      result = await policy.enforce(entity2);
    }
    return result;
  }
}
class AnyEntityPolicy {
  constructor(policies) {
    this.policies = policies;
  }
  async enforce(entity2) {
    for (const policy of this.policies) {
      try {
        return await policy.enforce(entity2);
      } catch {
        continue;
      }
    }
    throw new Error(`The entity did not match any known policy`);
  }
}
class EntityPolicies {
  static defaultPolicies() {
    return EntityPolicies.allOf([
      EntityPolicies.allOf([
        new SchemaValidEntityPolicy(),
        new DefaultNamespaceEntityPolicy(),
        new NoForeignRootFieldsEntityPolicy(),
        new FieldFormatEntityPolicy(),
        new ReservedFieldsEntityPolicy()
      ]),
      EntityPolicies.anyOf([
        new ComponentEntityV1alpha1Policy(),
        new GroupEntityV1alpha1Policy(),
        new LocationEntityV1alpha1Policy(),
        new TemplateEntityV1alpha1Policy(),
        new ApiEntityV1alpha1Policy()
      ])
    ]);
  }
  static allOf(policies) {
    return new AllEntityPolicies(policies);
  }
  static anyOf(policies) {
    return new AnyEntityPolicy(policies);
  }
  constructor(policy = EntityPolicies.defaultPolicies()) {
    this.policy = policy;
  }
  enforce(entity2) {
    return this.policy.enforce(entity2);
  }
}

const locationSpecSchema = yup.object({
  type: yup.string().required(),
  target: yup.string().required()
}).noUnknown();
const locationSchema = yup.object({
  id: yup.string().required(),
  type: yup.string().required(),
  target: yup.string().required()
}).noUnknown();

const LOCATION_ANNOTATION = "backstage.io/managed-by-location";

exports.ApiEntityV1alpha1Policy = ApiEntityV1alpha1Policy;
exports.CommonValidatorFunctions = CommonValidatorFunctions;
exports.ComponentEntityV1alpha1Policy = ComponentEntityV1alpha1Policy;
exports.DefaultNamespaceEntityPolicy = DefaultNamespaceEntityPolicy;
exports.EntityPolicies = EntityPolicies;
exports.FieldFormatEntityPolicy = FieldFormatEntityPolicy;
exports.GroupEntityV1alpha1Policy = GroupEntityV1alpha1Policy;
exports.KubernetesValidatorFunctions = KubernetesValidatorFunctions;
exports.LOCATION_ANNOTATION = LOCATION_ANNOTATION;
exports.LocationEntityV1alpha1Policy = LocationEntityV1alpha1Policy;
exports.NoForeignRootFieldsEntityPolicy = NoForeignRootFieldsEntityPolicy;
exports.ReservedFieldsEntityPolicy = ReservedFieldsEntityPolicy;
exports.SchemaValidEntityPolicy = SchemaValidEntityPolicy;
exports.TemplateEntityV1alpha1Policy = TemplateEntityV1alpha1Policy;
exports.entityHasChanges = entityHasChanges;
exports.entityMetaGeneratedFields = entityMetaGeneratedFields;
exports.generateEntityEtag = generateEntityEtag;
exports.generateEntityUid = generateEntityUid;
exports.generateUpdatedEntity = generateUpdatedEntity;
exports.locationSchema = locationSchema;
exports.locationSpecSchema = locationSpecSchema;
exports.makeValidator = makeValidator;
