/// <reference types="node" />
import { Entity, Location, LocationSpec, EntityPolicy } from '@backstage/catalog-model';
import Knex from 'knex';
import { Logger } from 'winston';
import { Config } from '@backstage/config';
import express from 'express';

declare type DbEntityRequest = {
    locationId?: string;
    entity: Entity;
};
declare type DbEntityResponse = {
    locationId?: string;
    entity: Entity;
};
declare type DbLocationsRow = {
    id: string;
    type: string;
    target: string;
};
declare type DbLocationsRowWithStatus = DbLocationsRow & {
    status: string | null;
    timestamp: string | null;
    message: string | null;
};
declare enum DatabaseLocationUpdateLogStatus {
    FAIL = "fail",
    SUCCESS = "success"
}
declare type DatabaseLocationUpdateLogEvent = {
    id: string;
    status: DatabaseLocationUpdateLogStatus;
    location_id: string;
    entity_name: string;
    created_at?: string;
    message?: string;
};
declare type EntityFilter = {
    key: string;
    values: (string | null)[];
};
declare type EntityFilters = EntityFilter[];
/**
 * An abstraction on top of the underlying database, wrapping the basic CRUD
 * needs.
 */
declare type Database = {
    /**
     * Runs a transaction.
     *
     * The callback is expected to make calls back into this class. When it
     * completes, the transaction is closed.
     *
     * @param fn The callback that implements the transaction
     */
    transaction<T>(fn: (tx: unknown) => Promise<T>): Promise<T>;
    /**
     * Adds a new entity to the catalog.
     *
     * @param tx An ongoing transaction
     * @param request The entity being added
     * @returns The added entity, with uid, etag and generation set
     */
    addEntity(tx: unknown, request: DbEntityRequest): Promise<DbEntityResponse>;
    /**
     * Updates an existing entity in the catalog.
     *
     * The given entity must contain an uid to identify an already stored entity
     * in the catalog. If it is missing or if no matching entity is found, the
     * operation fails.
     *
     * If matchingEtag or matchingGeneration are given, they are taken into
     * account. Attempts to update a matching entity, but where the etag and/or
     * generation are not equal to the passed values, will fail.
     *
     * @param tx An ongoing transaction
     * @param request The entity being updated
     * @param matchingEtag If specified, reject with ConflictError if not
     *                     matching the entry in the database
     * @param matchingGeneration If specified, reject with ConflictError if not
     *                           matching the entry in the database
     * @returns The updated entity
     */
    updateEntity(tx: unknown, request: DbEntityRequest, matchingEtag?: string, matchingGeneration?: number): Promise<DbEntityResponse>;
    entities(tx: unknown, filters?: EntityFilters): Promise<DbEntityResponse[]>;
    entity(tx: unknown, kind: string, name: string, namespace?: string): Promise<DbEntityResponse | undefined>;
    entityByUid(tx: unknown, uid: string): Promise<DbEntityResponse | undefined>;
    removeEntity(tx: unknown, uid: string): Promise<void>;
    addLocation(location: Location): Promise<DbLocationsRow>;
    removeLocation(tx: unknown, id: string): Promise<void>;
    location(id: string): Promise<DbLocationsRowWithStatus>;
    locations(): Promise<DbLocationsRowWithStatus[]>;
    locationHistory(id: string): Promise<DatabaseLocationUpdateLogEvent[]>;
    addLocationUpdateLogEvent(locationId: string, status: DatabaseLocationUpdateLogStatus, entityName?: string, message?: string): Promise<void>;
};

/**
 * The core database implementation.
 */
declare class CommonDatabase implements Database {
    private readonly database;
    private readonly normalize;
    private readonly logger;
    constructor(database: Knex, normalize: (value: string) => string, logger: Logger);
    transaction<T>(fn: (tx: unknown) => Promise<T>): Promise<T>;
    addEntity(txOpaque: unknown, request: DbEntityRequest): Promise<DbEntityResponse>;
    updateEntity(txOpaque: unknown, request: DbEntityRequest, matchingEtag?: string, matchingGeneration?: number): Promise<DbEntityResponse>;
    entities(txOpaque: unknown, filters?: EntityFilters): Promise<DbEntityResponse[]>;
    entity(txOpaque: unknown, kind: string, name: string, namespace?: string): Promise<DbEntityResponse | undefined>;
    entityByUid(txOpaque: unknown, id: string): Promise<DbEntityResponse | undefined>;
    removeEntity(txOpaque: unknown, uid: string): Promise<void>;
    addLocation(location: Location): Promise<DbLocationsRow>;
    removeLocation(txOpaque: unknown, id: string): Promise<void>;
    location(id: string): Promise<DbLocationsRowWithStatus>;
    locations(): Promise<DbLocationsRowWithStatus[]>;
    locationHistory(id: string): Promise<DatabaseLocationUpdateLogEvent[]>;
    addLocationUpdateLogEvent(locationId: string, status: DatabaseLocationUpdateLogStatus, entityName?: string, message?: string): Promise<void>;
    private updateEntitiesSearch;
    private ensureNoSimilarNames;
    private toEntityRow;
    private toEntityResponse;
}

declare type CreateDatabaseOptions = {
    logger: Logger;
    fieldNormalizer: (value: string) => string;
};
declare class DatabaseManager {
    static createDatabase(knex: Knex, options?: Partial<CreateDatabaseOptions>): Promise<Database>;
    static createInMemoryDatabase(options?: Partial<CreateDatabaseOptions>): Promise<Database>;
    static createTestDatabase(): Promise<Database>;
}

declare type EntitiesCatalog = {
    entities(filters?: EntityFilters): Promise<Entity[]>;
    entityByUid(uid: string): Promise<Entity | undefined>;
    entityByName(kind: string, namespace: string | undefined, name: string): Promise<Entity | undefined>;
    addOrUpdateEntity(entity: Entity, locationId?: string): Promise<Entity>;
    removeEntityByUid(uid: string): Promise<void>;
};
declare type LocationUpdateStatus = {
    timestamp: string | null;
    status: string | null;
    message: string | null;
};
declare type LocationUpdateLogEvent = {
    id: string;
    status: 'fail' | 'success';
    location_id: string;
    entity_name: string;
    created_at?: string;
    message?: string;
};
declare type LocationResponse = {
    data: Location;
    currentStatus: LocationUpdateStatus;
};
declare type LocationsCatalog = {
    addLocation(location: Location): Promise<Location>;
    removeLocation(id: string): Promise<void>;
    locations(): Promise<LocationResponse[]>;
    location(id: string): Promise<LocationResponse>;
    locationHistory(id: string): Promise<LocationUpdateLogEvent[]>;
    logUpdateSuccess(locationId: string, entityName?: string): Promise<void>;
    logUpdateFailure(locationId: string, error?: Error, entityName?: string): Promise<void>;
};

declare class DatabaseEntitiesCatalog implements EntitiesCatalog {
    private readonly database;
    constructor(database: Database);
    entities(filters?: EntityFilters): Promise<Entity[]>;
    entityByUid(uid: string): Promise<Entity | undefined>;
    entityByName(kind: string, namespace: string | undefined, name: string): Promise<Entity | undefined>;
    addOrUpdateEntity(entity: Entity, locationId?: string): Promise<Entity>;
    removeEntityByUid(uid: string): Promise<void>;
    private entityByNameInternal;
}

declare class DatabaseLocationsCatalog implements LocationsCatalog {
    private readonly database;
    constructor(database: Database);
    addLocation(location: Location): Promise<Location>;
    removeLocation(id: string): Promise<void>;
    locations(): Promise<LocationResponse[]>;
    locationHistory(id: string): Promise<DatabaseLocationUpdateLogEvent[]>;
    location(id: string): Promise<LocationResponse>;
    logUpdateSuccess(locationId: string, entityName?: string): Promise<void>;
    logUpdateFailure(locationId: string, error?: Error, entityName?: string): Promise<void>;
}

declare class StaticEntitiesCatalog implements EntitiesCatalog {
    private _entities;
    constructor(entities: Entity[]);
    entities(): Promise<Entity[]>;
    entityByUid(uid: string): Promise<Entity | undefined>;
    entityByName(kind: string, name: string, namespace: string | undefined): Promise<Entity | undefined>;
    addOrUpdateEntity(): Promise<Entity>;
    removeEntityByUid(): Promise<void>;
}

declare type HigherOrderOperation = {
    addLocation(spec: LocationSpec): Promise<AddLocationResult>;
    refreshAllLocations(): Promise<void>;
};
declare type AddLocationResult = {
    location: Location;
    entities: Entity[];
};
declare type LocationReader = {
    /**
     * Reads the contents of a location.
     *
     * @param location The location to read
     * @throws An error if the location was handled by this reader, but could not
     *         be read
     */
    read(location: LocationSpec): Promise<ReadLocationResult>;
};
declare type ReadLocationResult = {
    entities: ReadLocationEntity[];
    errors: ReadLocationError[];
};
declare type ReadLocationEntity = {
    location: LocationSpec;
    entity: Entity;
};
declare type ReadLocationError = {
    location: LocationSpec;
    error: Error;
};

/**
 * Placeholder for operations that span several catalogs and/or stretches out
 * in time.
 *
 * TODO(freben): Find a better home for these, possibly refactoring to use the
 * database more directly.
 */
declare class HigherOrderOperations implements HigherOrderOperation {
    private readonly entitiesCatalog;
    private readonly locationsCatalog;
    private readonly locationReader;
    private readonly logger;
    constructor(entitiesCatalog: EntitiesCatalog, locationsCatalog: LocationsCatalog, locationReader: LocationReader, logger: Logger);
    /**
     * Adds a single location to the catalog.
     *
     * The location is inspected and fetched, and all of the resulting data is
     * validated. If everything goes well, the location and entities are stored
     * in the catalog.
     *
     * If the location already existed, the old location is returned instead and
     * the catalog is left unchanged.
     *
     * @param spec The location to add
     */
    addLocation(spec: LocationSpec): Promise<AddLocationResult>;
    /**
     * Goes through all registered locations, and performs a refresh of each one.
     *
     * Entities are read from their respective sources, are parsed and validated
     * according to the entity policy, and get inserted or updated in the catalog.
     * Entities that have disappeared from their location are left orphaned,
     * without changes.
     */
    refreshAllLocations(): Promise<void>;
    private refreshSingleLocation;
}

declare type LocationProcessor = {
    /**
     * Reads the contents of a location.
     *
     * @param location The location to read
     * @param optional Whether a missing target should trigger an error
     * @param emit A sink for items resulting from the read
     * @returns True if handled by this processor, false otherwise
     */
    readLocation?(location: LocationSpec, optional: boolean, emit: LocationProcessorEmit): Promise<boolean>;
    /**
     * Parses a raw data buffer that was read from a location.
     *
     * @param data The data to parse
     * @param location The location that the data came from
     * @param emit A sink for items resulting from the parsing
     * @returns True if handled by this processor, false otherwise
     */
    parseData?(data: Buffer, location: LocationSpec, emit: LocationProcessorEmit): Promise<boolean>;
    /**
     * Processes an emitted entity, e.g. by validating or modifying it.
     *
     * @param entity The entity to process
     * @param location The location that the entity came from
     * @param emit A sink for auxiliary items resulting from the processing
     * @returns The same entity or a modifid version of it
     */
    processEntity?(entity: Entity, location: LocationSpec, emit: LocationProcessorEmit): Promise<Entity>;
    /**
     * Handles an emitted error.
     *
     * @param error The error
     * @param location The location where the error occurred
     * @param emit A sink for items resulting from this handilng
     * @returns Nothing
     */
    handleError?(error: Error, location: LocationSpec, emit: LocationProcessorEmit): Promise<void>;
};
declare type LocationProcessorEmit = (generated: LocationProcessorResult) => void;
declare type LocationProcessorLocationResult = {
    type: 'location';
    location: LocationSpec;
    optional: boolean;
};
declare type LocationProcessorDataResult = {
    type: 'data';
    data: Buffer;
    location: LocationSpec;
};
declare type LocationProcessorEntityResult = {
    type: 'entity';
    entity: Entity;
    location: LocationSpec;
};
declare type LocationProcessorErrorResult = {
    type: 'error';
    error: Error;
    location: LocationSpec;
};
declare type LocationProcessorResult = LocationProcessorLocationResult | LocationProcessorDataResult | LocationProcessorEntityResult | LocationProcessorErrorResult;

declare type Options = {
    logger?: Logger;
    config?: Config;
    processors?: LocationProcessor[];
};
/**
 * Implements the reading of a location through a series of processor tasks.
 */
declare class LocationReaders implements LocationReader {
    private readonly logger;
    private readonly processors;
    private readonly rulesEnforcer;
    static defaultProcessors(options: {
        config?: Config;
        entityPolicy?: EntityPolicy;
    }): LocationProcessor[];
    constructor({ logger, config, processors, }: Options);
    read(location: LocationSpec): Promise<ReadLocationResult>;
    private handleLocation;
    private handleData;
    private handleEntity;
    private handleError;
}

declare function notFoundError(atLocation: LocationSpec, message: string): LocationProcessorResult;
declare function inputError(atLocation: LocationSpec, message: string): LocationProcessorResult;
declare function generalError(atLocation: LocationSpec, message: string): LocationProcessorResult;
declare function data(atLocation: LocationSpec, newData: Buffer): LocationProcessorResult;
declare function location(newLocation: LocationSpec, optional: boolean): LocationProcessorResult;
declare function entity(atLocation: LocationSpec, newEntity: Entity): LocationProcessorResult;

declare const results_d_notFoundError: typeof notFoundError;
declare const results_d_inputError: typeof inputError;
declare const results_d_generalError: typeof generalError;
declare const results_d_data: typeof data;
declare const results_d_location: typeof location;
declare const results_d_entity: typeof entity;
declare namespace results_d {
  export {
    results_d_notFoundError as notFoundError,
    results_d_inputError as inputError,
    results_d_generalError as generalError,
    results_d_data as data,
    results_d_location as location,
    results_d_entity as entity,
  };
}

interface RouterOptions {
    entitiesCatalog?: EntitiesCatalog;
    locationsCatalog?: LocationsCatalog;
    higherOrderOperation?: HigherOrderOperation;
    logger: Logger;
}
declare function createRouter(options: RouterOptions): Promise<express.Router>;

/**
 * Runs a function repeatedly, with a fixed wait between invocations.
 *
 * Supports async functions, and silently ignores exceptions and rejections.
 *
 * @param fn The function to run. May return a Promise.
 * @param delayMs The delay between a completed function invocation and the
 *                next.
 * @returns A function that, when called, stops the invocation loop.
 */
declare function runPeriodically(fn: () => any, delayMs: number): () => void;

export { AddLocationResult, CommonDatabase, Database, DatabaseEntitiesCatalog, DatabaseLocationsCatalog, DatabaseManager, DbEntityRequest, DbEntityResponse, EntitiesCatalog, EntityFilter, EntityFilters, HigherOrderOperation, HigherOrderOperations, LocationProcessor, LocationProcessorDataResult, LocationProcessorEmit, LocationProcessorEntityResult, LocationProcessorErrorResult, LocationProcessorLocationResult, LocationProcessorResult, LocationReader, LocationReaders, LocationsCatalog, ReadLocationEntity, ReadLocationError, ReadLocationResult, RouterOptions, StaticEntitiesCatalog, createRouter, results_d as results, runPeriodically };
