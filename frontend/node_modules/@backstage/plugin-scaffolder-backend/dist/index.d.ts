/// <reference types="node" />
import { TemplateEntityV1alpha1 } from '@backstage/catalog-model';
import { Logger } from 'winston';
import { Writable } from 'stream';
import Docker from 'dockerode';
import { JsonValue } from '@backstage/config';
import { Octokit } from '@octokit/rest';
import express from 'express';

declare type PreparerBase = {
    /**
     * Given an Entity definition from the Service Catalog, go and prepare a directory
     * with contents from the remote location in temporary storage and return the path
     * @param template The template entity from the Service Catalog
     */
    prepare(template: TemplateEntityV1alpha1, opts: {
        logger: Logger;
    }): Promise<string>;
};
declare type PreparerBuilder = {
    register(protocol: RemoteProtocol, preparer: PreparerBase): void;
    get(template: TemplateEntityV1alpha1): PreparerBase;
};
declare type RemoteProtocol = 'file' | 'github';

declare class Preparers implements PreparerBuilder {
    private preparerMap;
    register(protocol: RemoteProtocol, preparer: PreparerBase): void;
    get(template: TemplateEntityV1alpha1): PreparerBase;
}

declare type ParsedLocationAnnotation = {
    protocol: RemoteProtocol;
    location: string;
};
declare const parseLocationAnnotation: (entity: TemplateEntityV1alpha1) => ParsedLocationAnnotation;

declare class FilePreparer implements PreparerBase {
    prepare(template: TemplateEntityV1alpha1): Promise<string>;
}

declare class GithubPreparer implements PreparerBase {
    prepare(template: TemplateEntityV1alpha1): Promise<string>;
}

/**
 * Currently the required template values. The owner
 * and where to store the result from templating
 */
declare type RequiredTemplateValues = {
    owner: string;
    storePath: string;
};
/**
 * The returned directory from the templater which is ready
 * to pass to the next stage of the scaffolder which is publishing
 */
declare type TemplaterRunResult = {
    resultDir: string;
};
/**
 * The values that the templater will receive. The directory of the
 * skeleton, with the values from the frontend. A dedicated log stream and a docker
 * client to run any templater on top of your directory.
 */
declare type TemplaterRunOptions = {
    directory: string;
    values: RequiredTemplateValues & Record<string, JsonValue>;
    logStream?: Writable;
    dockerClient: Docker;
};
declare type TemplaterBase = {
    run(opts: TemplaterRunOptions): Promise<TemplaterRunResult>;
};
declare type TemplaterConfig = {
    templater?: TemplaterBase;
};
/**
 * List of supported templating options
 */
declare type SupportedTemplatingKey = 'cookiecutter' | string;
/**
 * The templater builder holds the templaters ready for run time
 */
declare type TemplaterBuilder = {
    register(protocol: SupportedTemplatingKey, templater: TemplaterBase): void;
    get(template: TemplateEntityV1alpha1): TemplaterBase;
};

declare class CookieCutter implements TemplaterBase {
    private fetchTemplateCookieCutter;
    run(options: TemplaterRunOptions): Promise<TemplaterRunResult>;
}

declare type RunDockerContainerOptions = {
    imageName: string;
    args: string[];
    logStream?: Writable;
    resultDir: string;
    templateDir: string;
    dockerClient: Docker;
    createOptions?: Docker.ContainerCreateOptions;
};
declare type RunCommandOptions = {
    command: string;
    args: string[];
    logStream?: Writable;
};
/**
 * Gets the templater key to use for templating from the entity
 * @param entity Template entity
 */
declare const getTemplaterKey: (entity: TemplateEntityV1alpha1) => string;
/**
 *
 * @param options the options object
 * @param options.command the command to run
 * @param options.args the arguments to pass the command
 * @param options.logStream the log streamer to capture log messages
 */
declare const runCommand: ({ command, args, logStream, }: RunCommandOptions) => Promise<void>;
/**
 *
 * @param options the options object
 * @param options.imageName the image to run
 * @param options.args the arguments to pass the container
 * @param options.logStream the log streamer to capture log messages
 * @param options.resultDir the /result path inside the container
 * @param options.templateDir the /template path inside the container
 * @param options.dockerClient the dockerClient to use
 */
declare const runDockerContainer: ({ imageName, args, logStream, resultDir, templateDir, dockerClient, createOptions, }: RunDockerContainerOptions) => Promise<{
    error: any;
    statusCode: any;
}>;

declare class Templaters implements TemplaterBuilder {
    private preparerMap;
    register(templaterKey: SupportedTemplatingKey, templater: TemplaterBase): void;
    get(template: TemplateEntityV1alpha1): TemplaterBase;
}

declare class CreateReactAppTemplater implements TemplaterBase {
    run(options: TemplaterRunOptions): Promise<TemplaterRunResult>;
}

/**
 * Publisher is in charge of taking a folder created by
 * the templater, and pushing it to a remote storage
 */
declare type PublisherBase = {
    /**
     *
     * @param opts object containing the template entity from the service
     *             catalog, plus the values from the form and the directory that has
     *             been templated
     */
    publish(opts: {
        entity: TemplateEntityV1alpha1;
        values: RequiredTemplateValues & Record<string, JsonValue>;
        directory: string;
    }): Promise<{
        remoteUrl: string;
    }>;
};

declare class GithubPublisher implements PublisherBase {
    private client;
    constructor({ client }: {
        client: Octokit;
    });
    publish({ values, directory, }: {
        values: RequiredTemplateValues & Record<string, JsonValue>;
        directory: string;
    }): Promise<{
        remoteUrl: string;
    }>;
    private createRemote;
    private pushToRemote;
}

declare type StageContext<T = {}> = {
    values: RequiredTemplateValues & Record<string, JsonValue>;
    entity: TemplateEntityV1alpha1;
    logger: Logger;
    logStream: Writable;
} & T;
declare type ProcessorStatus = 'PENDING' | 'STARTED' | 'COMPLETED' | 'FAILED';
interface StageResult extends StageInput {
    log: string[];
    status: ProcessorStatus;
    startedAt?: number;
    endedAt?: number;
}
interface StageInput<T = {}> {
    name: string;
    handler(ctx: StageContext<T>): Promise<void | object>;
}
declare type Job = {
    id: string;
    context: StageContext;
    status: ProcessorStatus;
    stages: StageResult[];
    error?: Error;
};
declare type Processor = {
    create({ entity, values, stages, }: {
        entity: TemplateEntityV1alpha1;
        values: RequiredTemplateValues & Record<string, JsonValue>;
        stages: StageInput[];
    }): Job;
    get(id: string): Job | undefined;
    run(job: Job): Promise<void>;
};

declare type JobProcessorArguments = {
    preparers: PreparerBuilder;
    templater: TemplaterBase;
    dockerClient: Docker;
};
declare type JobAndDirectoryTuple = {
    job: Job;
    directory: string;
};
declare class JobProcessor implements Processor {
    private jobs;
    create({ entity, values, stages, }: {
        entity: TemplateEntityV1alpha1;
        values: RequiredTemplateValues & Record<string, JsonValue>;
        stages: StageInput[];
    }): Job;
    get(id: string): Job | undefined;
    run(job: Job): Promise<void>;
}

interface RouterOptions {
    preparers: PreparerBuilder;
    templaters: TemplaterBuilder;
    publisher: PublisherBase;
    logger: Logger;
    dockerClient: Docker;
}
declare function createRouter(options: RouterOptions): Promise<express.Router>;

export { CookieCutter, CreateReactAppTemplater, FilePreparer, GithubPreparer, GithubPublisher, Job, JobAndDirectoryTuple, JobProcessor, JobProcessorArguments, ParsedLocationAnnotation, PreparerBase, PreparerBuilder, Preparers, Processor, ProcessorStatus, PublisherBase, RemoteProtocol, RequiredTemplateValues, RouterOptions, RunCommandOptions, RunDockerContainerOptions, StageContext, StageInput, StageResult, SupportedTemplatingKey, TemplaterBase, TemplaterBuilder, TemplaterConfig, TemplaterRunOptions, TemplaterRunResult, Templaters, createRouter, getTemplaterKey, parseLocationAnnotation, runCommand, runDockerContainer };
