'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var catalogModel = require('@backstage/catalog-model');
var backendCommon = require('@backstage/backend-common');
var fs = _interopDefault(require('fs-extra'));
var path2 = _interopDefault(require('path'));
var os2 = _interopDefault(require('os'));
var GitUriParser = _interopDefault(require('git-url-parse'));
var nodegit = require('nodegit');
var stream = require('stream');
var fs2 = _interopDefault(require('fs'));
var child_process = require('child_process');
var yaml = require('yaml');
var uuid = require('uuid');
var winston = require('winston');
var express2 = _interopDefault(require('express'));
var Router = _interopDefault(require('express-promise-router'));

const parseLocationAnnotation = (entity) => {
  var _a;
  const annotation = (_a = entity.metadata.annotations) == null ? void 0 : _a[catalogModel.LOCATION_ANNOTATION];
  if (!annotation) {
    throw new backendCommon.InputError(`No location annotation provided in entity: ${entity.metadata.name}`);
  }
  const [protocol, location] = annotation.split(/:(.+)/);
  if (!protocol || !location) {
    throw new backendCommon.InputError(`Failure to parse either protocol or location for entity: ${entity.metadata.name}`);
  }
  return {
    protocol,
    location
  };
};

class Preparers {
  constructor() {
    this.preparerMap = new Map();
  }
  register(protocol, preparer) {
    this.preparerMap.set(protocol, preparer);
  }
  get(template) {
    const {protocol} = parseLocationAnnotation(template);
    const preparer = this.preparerMap.get(protocol);
    if (!preparer) {
      throw new Error(`No preparer registered for type: "${protocol}"`);
    }
    return preparer;
  }
}

class FilePreparer {
  async prepare(template) {
    var _a;
    const {protocol, location} = parseLocationAnnotation(template);
    if (protocol !== "file") {
      throw new backendCommon.InputError(`Wrong location protocol: ${protocol}, should be 'file'`);
    }
    const templateId = template.metadata.name;
    const tempDir = await fs.promises.mkdtemp(path2.join(os2.tmpdir(), templateId));
    const parentDirectory = path2.resolve(path2.dirname(location), (_a = template.spec.path) != null ? _a : ".");
    await fs.copy(parentDirectory, tempDir, {
      filter: (src) => src !== location,
      recursive: true
    });
    return tempDir;
  }
}

class GithubPreparer {
  async prepare(template) {
    var _a;
    const {protocol, location} = parseLocationAnnotation(template);
    if (protocol !== "github") {
      throw new backendCommon.InputError(`Wrong location protocol: ${protocol}, should be 'github'`);
    }
    const templateId = template.metadata.name;
    const parsedGitLocation = GitUriParser(location);
    const repositoryCheckoutUrl = parsedGitLocation.toString("https");
    const tempDir = await fs.promises.mkdtemp(path2.join(os2.tmpdir(), templateId));
    const templateDirectory = path2.join(`${path2.dirname(parsedGitLocation.filepath)}`, (_a = template.spec.path) != null ? _a : ".");
    await nodegit.Clone.clone(repositoryCheckoutUrl, tempDir, {});
    return path2.resolve(tempDir, templateDirectory);
  }
}

class GithubPublisher {
  constructor({client}) {
    this.client = client;
  }
  async publish({
    values,
    directory
  }) {
    const remoteUrl = await this.createRemote(values);
    await this.pushToRemote(directory, remoteUrl);
    return {remoteUrl};
  }
  async createRemote(values) {
    const [owner, name] = values.storePath.split("/");
    const repoCreationPromise = values.isOrg ? this.client.repos.createInOrg({name, org: owner}) : this.client.repos.createForAuthenticatedUser({name});
    const {data} = await repoCreationPromise;
    return data == null ? void 0 : data.clone_url;
  }
  async pushToRemote(directory, remote) {
    const repo = await nodegit.Repository.init(directory, 0);
    const index = await repo.refreshIndex();
    await index.addAll();
    await index.write();
    const oid = await index.writeTree();
    await repo.createCommit("HEAD", nodegit.Signature.now("Scaffolder", "scaffolder@backstage.io"), nodegit.Signature.now("Scaffolder", "scaffolder@backstage.io"), "initial commit", oid, []);
    const remoteRepo = await nodegit.Remote.create(repo, "origin", remote);
    await remoteRepo.push(["refs/heads/master:refs/heads/master"], {
      callbacks: {
        credentials: () => {
          return nodegit.Cred.userpassPlaintextNew(process.env.GITHUB_ACCESS_TOKEN, "x-oauth-basic");
        }
      }
    });
  }
}

const getTemplaterKey = (entity) => {
  const {templater} = entity.spec;
  if (!templater) {
    throw new backendCommon.InputError("Template does not have a required templating key");
  }
  return templater;
};
const runCommand = async ({
  command,
  args,
  logStream = new stream.PassThrough()
}) => {
  await new Promise((resolve, reject) => {
    const process2 = child_process.spawn(command, args);
    process2.stdout.on("data", (stream2) => {
      logStream.write(stream2);
    });
    process2.stderr.on("data", (stream2) => {
      logStream.write(stream2);
    });
    process2.on("error", (error) => {
      return reject(error);
    });
    process2.on("close", (code) => {
      if (code !== 0) {
        return reject(`Command ${command} failed, exit code: ${code}`);
      }
      return resolve();
    });
  });
};
const runDockerContainer = async ({
  imageName,
  args,
  logStream = new stream.PassThrough(),
  resultDir,
  templateDir,
  dockerClient,
  createOptions = {}
}) => {
  await new Promise((resolve, reject) => {
    dockerClient.pull(imageName, {}, (err, stream2) => {
      if (err)
        return reject(err);
      stream2.pipe(logStream, {end: false});
      stream2.on("end", () => resolve());
      stream2.on("error", (error2) => reject(error2));
      return void 0;
    });
  });
  const [{Error: error, StatusCode: statusCode}] = await dockerClient.run(imageName, args, logStream, {
    Volumes: {"/result": {}, "/template": {}},
    HostConfig: {
      Binds: [
        `${await fs2.promises.realpath(resultDir)}:/result`,
        `${await fs2.promises.realpath(templateDir)}:/template`
      ]
    },
    User: `${process.getuid()}:${process.getgid()}`,
    Env: ["HOME=/tmp"],
    ...createOptions
  });
  if (error) {
    throw new Error(`Docker failed to run with the following error message: ${error}`);
  }
  if (statusCode !== 0) {
    throw new Error(`Docker container returned a non-zero exit code (${statusCode})`);
  }
  return {error, statusCode};
};

const commandExists = require("command-exists-promise");
class CookieCutter {
  async fetchTemplateCookieCutter(directory) {
    try {
      return await fs.readJSON(`${directory}/cookiecutter.json`);
    } catch (ex) {
      if (ex.code !== "ENOENT") {
        throw ex;
      }
      return {};
    }
  }
  async run(options) {
    const cookieCutterJson = await this.fetchTemplateCookieCutter(options.directory);
    const cookieInfo = {
      ...cookieCutterJson,
      ...options.values
    };
    await fs.writeJSON(`${options.directory}/cookiecutter.json`, cookieInfo);
    const templateDir = options.directory;
    const resultDir = await fs.promises.mkdtemp(`${options.directory}-result`);
    const cookieCutterInstalled = await commandExists("cookiecutter");
    if (cookieCutterInstalled) {
      await runCommand({
        command: "cookiecutter",
        args: ["--no-input", "-o", resultDir, templateDir, "--verbose"],
        logStream: options.logStream
      });
    } else {
      await runDockerContainer({
        imageName: "spotify/backstage-cookiecutter",
        args: [
          "cookiecutter",
          "--no-input",
          "-o",
          "/result",
          "/template",
          "--verbose"
        ],
        templateDir,
        resultDir,
        logStream: options.logStream,
        dockerClient: options.dockerClient
      });
    }
    return {
      resultDir: path2.resolve(resultDir, options.values.component_id)
    };
  }
}

class Templaters {
  constructor() {
    this.preparerMap = new Map();
  }
  register(templaterKey, templater) {
    this.preparerMap.set(templaterKey, templater);
  }
  get(template) {
    const templaterKey = getTemplaterKey(template);
    const preparer = this.preparerMap.get(templaterKey);
    if (!preparer) {
      throw new Error(`No templater registered for template: "${templaterKey}"`);
    }
    return preparer;
  }
}

class CreateReactAppTemplater {
  async run(options) {
    const {
      component_id: componentName,
      use_typescript: withTypescript,
      description,
      owner
    } = options.values;
    const resultDir = await fs.promises.mkdtemp(`${options.directory}-result`);
    await runDockerContainer({
      imageName: "node:lts-alpine",
      args: [
        "create-react-app",
        componentName,
        withTypescript ? " --template typescript" : ""
      ],
      templateDir: options.directory,
      resultDir,
      logStream: options.logStream,
      dockerClient: options.dockerClient,
      createOptions: {
        Entrypoint: ["npx"],
        WorkingDir: "/result"
      }
    });
    const componentInfo = {
      apiVersion: "backstage.io/v1alpha1",
      kind: "Component",
      metadata: {
        name: componentName,
        description
      },
      spec: {
        type: "website",
        lifecycle: "experimental",
        owner
      }
    };
    const finalDir = path2.resolve(resultDir, options.values.component_id);
    await fs.promises.writeFile(`${finalDir}/component-info.yaml`, yaml.stringify(componentInfo));
    return {
      resultDir: finalDir
    };
  }
}

const makeLogStream = (meta) => {
  const log = [];
  const stream2 = new stream.PassThrough();
  stream2.on("data", (chunk) => {
    const textValue = chunk.toString().trim();
    if ((textValue == null ? void 0 : textValue.length) > 1)
      log.push(textValue);
  });
  const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || "info",
    format: winston.format.combine(winston.format.colorize(), winston.format.timestamp(), winston.format.simple()),
    defaultMeta: meta
  });
  logger.add(new winston.transports.Stream({stream: stream2}));
  return {
    log,
    stream: stream2,
    logger
  };
};

class JobProcessor {
  constructor() {
    this.jobs = new Map();
  }
  create({
    entity,
    values,
    stages
  }) {
    const id = uuid.v4();
    const {logger: logger2, stream} = makeLogStream({id});
    const context = {
      entity,
      values,
      logger: logger2,
      logStream: stream
    };
    const job = {
      id,
      context,
      stages: stages.map((stage) => ({
        handler: stage.handler,
        log: [],
        name: stage.name,
        status: "PENDING"
      })),
      status: "PENDING"
    };
    this.jobs.set(job.id, job);
    return job;
  }
  get(id) {
    return this.jobs.get(id);
  }
  async run(job) {
    if (job.status !== "PENDING") {
      throw new Error("Job is not in a 'PENDING' state");
    }
    job.status = "STARTED";
    try {
      for (const stage of job.stages) {
        const {logger: logger2, log, stream} = makeLogStream({
          id: job.id,
          stage: stage.name
        });
        stage.log = log;
        stage.startedAt = Date.now();
        try {
          stage.status = "STARTED";
          const handlerResponse = await stage.handler({
            ...job.context,
            logger: logger2,
            logStream: stream
          });
          if (handlerResponse) {
            job.context = {
              ...job.context,
              ...handlerResponse
            };
          }
          stage.status = "COMPLETED";
        } catch (error) {
          logger2.error(`Stage failed with error: ${error.message}`);
          stage.status = "FAILED";
          throw error;
        } finally {
          stage.endedAt = Date.now();
        }
      }
      job.status = "COMPLETED";
    } catch (error) {
      job.error = {name: error.name, message: error.message};
      job.status = "FAILED";
    }
  }
}

async function createRouter(options) {
  const router = Router();
  router.use(express2.json());
  const {
    preparers,
    templaters,
    publisher,
    logger: parentLogger,
    dockerClient
  } = options;
  const logger = parentLogger.child({plugin: "scaffolder"});
  const jobProcessor = new JobProcessor();
  router.get("/v1/job/:jobId", ({params}, res) => {
    const job = jobProcessor.get(params.jobId);
    if (!job) {
      res.status(404).send({error: "job not found"});
      return;
    }
    res.send({
      id: job.id,
      metadata: {
        ...job.context,
        logger: void 0,
        logStream: void 0
      },
      status: job.status,
      stages: job.stages.map((stage) => ({
        ...stage,
        handler: void 0
      })),
      error: job.error
    });
  }).post("/v1/jobs", async (req, res) => {
    const template = req.body.template;
    const values = req.body.values;
    const job = jobProcessor.create({
      entity: template,
      values,
      stages: [
        {
          name: "Prepare the skeleton",
          handler: async (ctx) => {
            const preparer = preparers.get(ctx.entity);
            const skeletonDir = await preparer.prepare(ctx.entity, {
              logger: ctx.logger
            });
            return {skeletonDir};
          }
        },
        {
          name: "Run the templater",
          handler: async (ctx) => {
            const templater = templaters.get(ctx.entity);
            const {resultDir} = await templater.run({
              directory: ctx.skeletonDir,
              dockerClient,
              logStream: ctx.logStream,
              values: ctx.values
            });
            return {resultDir};
          }
        },
        {
          name: "Publish template",
          handler: async (ctx) => {
            ctx.logger.info("Will now store the template");
            const {remoteUrl} = await publisher.publish({
              entity: ctx.entity,
              values: ctx.values,
              directory: ctx.resultDir
            });
            return {remoteUrl};
          }
        }
      ]
    });
    res.status(201).json({id: job.id});
    jobProcessor.run(job);
  });
  const app = express2();
  app.set("logger", logger);
  app.use("/", router);
  return app;
}

exports.CookieCutter = CookieCutter;
exports.CreateReactAppTemplater = CreateReactAppTemplater;
exports.FilePreparer = FilePreparer;
exports.GithubPreparer = GithubPreparer;
exports.GithubPublisher = GithubPublisher;
exports.JobProcessor = JobProcessor;
exports.Preparers = Preparers;
exports.Templaters = Templaters;
exports.createRouter = createRouter;
exports.getTemplaterKey = getTemplaterKey;
exports.parseLocationAnnotation = parseLocationAnnotation;
exports.runCommand = runCommand;
exports.runDockerContainer = runDockerContainer;
