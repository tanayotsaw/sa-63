'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var express2 = _interopDefault(require('express'));
var Router = _interopDefault(require('express-promise-router'));
var cookieParser = _interopDefault(require('cookie-parser'));
var passportGithub2 = require('passport-github2');
var jwtDecoder = _interopDefault(require('jwt-decode'));
var crypto2 = _interopDefault(require('crypto'));
var url = require('url');
var backendCommon = require('@backstage/backend-common');
var passportGitlab2 = require('passport-gitlab2');
var passportGoogleOauth20 = require('passport-google-oauth20');
var OAuth2Strategy = require('passport-oauth2');
var OAuth2Strategy__default = _interopDefault(OAuth2Strategy);
var passportOktaOauth = require('passport-okta-oauth');
var passportSaml = require('passport-saml');
var passportMicrosoft = require('passport-microsoft');
var got2 = _interopDefault(require('got'));
var moment2 = require('moment');
var moment2__default = _interopDefault(moment2);
var jose = require('jose');
var uuid = require('uuid');

const makeProfileInfo = (profile, idToken) => {
  const {displayName} = profile;
  let email = void 0;
  if (profile.emails && profile.emails.length > 0) {
    const [firstEmail] = profile.emails;
    email = firstEmail.value;
  }
  let picture = void 0;
  if (profile.photos) {
    const [firstPhoto] = profile.photos;
    picture = firstPhoto.value;
  }
  if ((!email || !picture) && idToken) {
    try {
      const decoded = jwtDecoder(idToken);
      if (!email && decoded.email) {
        email = decoded.email;
      }
      if (!picture && decoded.picture) {
        picture = decoded.picture;
      }
    } catch (e) {
      throw new Error(`Failed to parse id token and get profile info, ${e}`);
    }
  }
  return {
    email,
    picture,
    displayName
  };
};
const executeRedirectStrategy = async (req, providerStrategy, options) => {
  return new Promise((resolve) => {
    const strategy = Object.create(providerStrategy);
    strategy.redirect = (url, status) => {
      resolve({url, status: status != null ? status : void 0});
    };
    strategy.authenticate(req, {...options});
  });
};
const executeFrameHandlerStrategy = async (req, providerStrategy) => {
  return new Promise((resolve, reject) => {
    const strategy = Object.create(providerStrategy);
    strategy.success = (response, privateInfo) => {
      resolve({response, privateInfo});
    };
    strategy.fail = (info) => {
      var _a;
      reject(new Error(`Authentication rejected, ${(_a = info.message) != null ? _a : ""}`));
    };
    strategy.error = (error) => {
      reject(new Error(`Authentication failed, ${error}`));
    };
    strategy.redirect = () => {
      reject(new Error("Unexpected redirect"));
    };
    strategy.authenticate(req, {});
  });
};
const executeRefreshTokenStrategy = async (providerStrategy, refreshToken, scope) => {
  return new Promise((resolve, reject) => {
    const anyStrategy = providerStrategy;
    const OAuth2 = anyStrategy._oauth2.constructor;
    const oauth2 = new OAuth2(anyStrategy._oauth2._clientId, anyStrategy._oauth2._clientSecret, anyStrategy._oauth2._baseSite, anyStrategy._oauth2._authorizeUrl, anyStrategy._refreshURL || anyStrategy._oauth2._accessTokenUrl, anyStrategy._oauth2._customHeaders);
    oauth2.getOAuthAccessToken(refreshToken, {
      scope,
      grant_type: "refresh_token"
    }, (err, accessToken, newRefreshToken, params) => {
      if (err) {
        reject(new Error(`Failed to refresh access token ${err.toString()}`));
      }
      if (!accessToken) {
        reject(new Error(`Failed to refresh access token, no access token received`));
      }
      resolve({
        accessToken,
        refreshToken: newRefreshToken,
        params
      });
    });
  });
};
const executeFetchUserProfileStrategy = async (providerStrategy, accessToken, idToken) => {
  return new Promise((resolve, reject) => {
    const anyStrategy = providerStrategy;
    anyStrategy.userProfile(accessToken, (error, passportProfile) => {
      if (error) {
        reject(error);
      }
      const profile = makeProfileInfo(passportProfile, idToken);
      resolve(profile);
    });
  });
};

const THOUSAND_DAYS_MS = 1e3 * 24 * 60 * 60 * 1e3;
const TEN_MINUTES_MS = 600 * 1e3;
const readState = (stateString) => {
  var _a, _b;
  const state = Object.fromEntries(new URLSearchParams(decodeURIComponent(stateString)));
  if (!state.nonce || !state.env || ((_a = state.nonce) == null ? void 0 : _a.length) === 0 || ((_b = state.env) == null ? void 0 : _b.length) === 0) {
    throw Error(`Invalid state passed via request`);
  }
  return {
    nonce: state.nonce,
    env: state.env
  };
};
const encodeState = (state) => {
  const searchParams = new URLSearchParams();
  searchParams.append("nonce", state.nonce);
  searchParams.append("env", state.env);
  return encodeURIComponent(searchParams.toString());
};
const verifyNonce = (req, providerId) => {
  var _a, _b;
  const cookieNonce = req.cookies[`${providerId}-nonce`];
  const state = readState((_b = (_a = req.query.state) == null ? void 0 : _a.toString()) != null ? _b : "");
  const stateNonce = state.nonce;
  if (!cookieNonce) {
    throw new Error("Auth response is missing cookie nonce");
  }
  if (stateNonce.length === 0) {
    throw new Error("Auth response is missing state nonce");
  }
  if (cookieNonce !== stateNonce) {
    throw new Error("Invalid nonce");
  }
};
const postMessageResponse = (res, appOrigin, response) => {
  const jsonData = JSON.stringify(response);
  const base64Data = Buffer.from(jsonData, "utf8").toString("base64");
  res.setHeader("Content-Type", "text/html");
  res.setHeader("X-Frame-Options", "sameorigin");
  const script = `
    (window.opener || window.parent).postMessage(JSON.parse(atob('${base64Data}')), '${appOrigin}')
    window.close()
  `;
  const hash = crypto2.createHash("sha256").update(script).digest("base64");
  res.setHeader("Content-Security-Policy", `script-src 'sha256-${hash}'`);
  res.end(`
<html>
<body>
  <script>${script}</script>
</body>
</html>
  `);
};
const ensuresXRequestedWith = (req) => {
  const requiredHeader = req.header("X-Requested-With");
  if (!requiredHeader || requiredHeader !== "XMLHttpRequest") {
    return false;
  }
  return true;
};
class OAuthProvider {
  constructor(providerHandlers, options) {
    this.providerHandlers = providerHandlers;
    this.options = options;
    this.setNonceCookie = (res, nonce) => {
      res.cookie(`${this.options.providerId}-nonce`, nonce, {
        maxAge: TEN_MINUTES_MS,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: `${this.options.cookiePath}/handler`,
        httpOnly: true
      });
    };
    this.setScopesCookie = (res, scope) => {
      res.cookie(`${this.options.providerId}-scope`, scope, {
        maxAge: TEN_MINUTES_MS,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: `${this.options.cookiePath}/handler`,
        httpOnly: true
      });
    };
    this.getScopesFromCookie = (req, providerId) => {
      return req.cookies[`${providerId}-scope`];
    };
    this.setRefreshTokenCookie = (res, refreshToken) => {
      res.cookie(`${this.options.providerId}-refresh-token`, refreshToken, {
        maxAge: THOUSAND_DAYS_MS,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: this.options.cookiePath,
        httpOnly: true
      });
    };
    this.removeRefreshTokenCookie = (res) => {
      res.cookie(`${this.options.providerId}-refresh-token`, "", {
        maxAge: 0,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: this.options.cookiePath,
        httpOnly: true
      });
    };
  }
  static fromConfig(config, providerHandlers, options) {
    const {origin: appOrigin} = new url.URL(config.appUrl);
    const secure = config.baseUrl.startsWith("https://");
    const url2 = new url.URL(config.baseUrl);
    const cookiePath = `${url2.pathname}/${options.providerId}`;
    return new OAuthProvider(providerHandlers, {
      ...options,
      appOrigin,
      cookieDomain: url2.hostname,
      cookiePath,
      secure
    });
  }
  async start(req, res) {
    var _a, _b, _c;
    const scope = (_b = (_a = req.query.scope) == null ? void 0 : _a.toString()) != null ? _b : "";
    const env = (_c = req.query.env) == null ? void 0 : _c.toString();
    if (!env) {
      throw new backendCommon.InputError("No env provided in request query parameters");
    }
    if (this.options.persistScopes) {
      this.setScopesCookie(res, scope);
    }
    const nonce = crypto2.randomBytes(16).toString("base64");
    this.setNonceCookie(res, nonce);
    const stateObject = {nonce, env};
    const stateParameter = encodeState(stateObject);
    const queryParameters = {
      scope,
      state: stateParameter
    };
    const {url: url2, status} = await this.providerHandlers.start(req, queryParameters);
    res.statusCode = status || 302;
    res.setHeader("Location", url2);
    res.setHeader("Content-Length", "0");
    res.end();
  }
  async frameHandler(req, res) {
    try {
      verifyNonce(req, this.options.providerId);
      const {response, refreshToken} = await this.providerHandlers.handler(req);
      if (this.options.persistScopes) {
        const grantedScopes = this.getScopesFromCookie(req, this.options.providerId);
        response.providerInfo.scope = grantedScopes;
      }
      if (!this.options.disableRefresh) {
        if (!refreshToken) {
          throw new backendCommon.InputError("Missing refresh token");
        }
        this.setRefreshTokenCookie(res, refreshToken);
      }
      await this.populateIdentity(response.backstageIdentity);
      return postMessageResponse(res, this.options.appOrigin, {
        type: "authorization_response",
        response
      });
    } catch (error) {
      return postMessageResponse(res, this.options.appOrigin, {
        type: "authorization_response",
        error: {
          name: error.name,
          message: error.message
        }
      });
    }
  }
  async logout(req, res) {
    if (!ensuresXRequestedWith(req)) {
      res.status(401).send("Invalid X-Requested-With header");
      return;
    }
    if (!this.options.disableRefresh) {
      this.removeRefreshTokenCookie(res);
    }
    res.send("logout!");
  }
  async refresh(req, res) {
    var _a, _b;
    if (!ensuresXRequestedWith(req)) {
      res.status(401).send("Invalid X-Requested-With header");
      return;
    }
    if (!this.providerHandlers.refresh || this.options.disableRefresh) {
      res.send(`Refresh token not supported for provider: ${this.options.providerId}`);
      return;
    }
    try {
      const refreshToken = req.cookies[`${this.options.providerId}-refresh-token`];
      if (!refreshToken) {
        throw new Error("Missing session cookie");
      }
      const scope = (_b = (_a = req.query.scope) == null ? void 0 : _a.toString()) != null ? _b : "";
      const response = await this.providerHandlers.refresh(refreshToken, scope);
      await this.populateIdentity(response.backstageIdentity);
      if (response.providerInfo.refreshToken && response.providerInfo.refreshToken !== refreshToken) {
        this.setRefreshTokenCookie(res, response.providerInfo.refreshToken);
      }
      res.send(response);
    } catch (error) {
      res.status(401).send(`${error.message}`);
    }
  }
  identifyEnv(req) {
    var _a, _b;
    const reqEnv = (_a = req.query.env) == null ? void 0 : _a.toString();
    if (reqEnv) {
      return reqEnv;
    }
    const stateParams = (_b = req.query.state) == null ? void 0 : _b.toString();
    if (!stateParams) {
      return void 0;
    }
    const env = readState(stateParams).env;
    return env;
  }
  async populateIdentity(identity2) {
    if (!identity2) {
      return;
    }
    if (!identity2.idToken) {
      identity2.idToken = await this.options.tokenIssuer.issueToken({
        claims: {sub: identity2.id}
      });
    }
  }
}

class GithubAuthProvider {
  static transformPassportProfile(rawProfile) {
    const profile = {
      id: rawProfile.username,
      username: rawProfile.username,
      provider: rawProfile.provider,
      displayName: rawProfile.displayName || rawProfile.username,
      photos: rawProfile.photos,
      emails: rawProfile.emails
    };
    return profile;
  }
  static transformOAuthResponse(accessToken, rawProfile, params = {}) {
    const passportProfile = GithubAuthProvider.transformPassportProfile(rawProfile);
    const profile = makeProfileInfo(passportProfile, params.id_token);
    const providerInfo = {
      accessToken,
      scope: params.scope,
      expiresInSeconds: params.expires_in,
      idToken: params.id_token
    };
    const id = passportProfile.id;
    if (params.expires_in) {
      providerInfo.expiresInSeconds = params.expires_in;
    }
    if (params.id_token) {
      providerInfo.idToken = params.id_token;
    }
    return {
      providerInfo,
      profile,
      backstageIdentity: {
        id
      }
    };
  }
  constructor(options) {
    this._strategy = new passportGithub2.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      tokenURL: options.tokenUrl,
      userProfileURL: options.userProfileUrl,
      authorizationURL: options.authorizationUrl
    }, (accessToken, _, params, rawProfile, done) => {
      const oauthResponse = GithubAuthProvider.transformOAuthResponse(accessToken, rawProfile, params);
      done(void 0, oauthResponse);
    });
  }
  async start(req, options) {
    return await executeRedirectStrategy(req, this._strategy, options);
  }
  async handler(req) {
    const {response} = await executeFrameHandlerStrategy(req, this._strategy);
    return {response};
  }
}
function createGithubProvider(config2, _, envConfig, _logger, tokenIssuer) {
  const providerId = "github";
  const clientId = envConfig.getString("clientId");
  const clientSecret = envConfig.getString("clientSecret");
  const enterpriseInstanceUrl = envConfig.getOptionalString("enterpriseInstanceUrl");
  const authorizationUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/login/oauth/authorize` : void 0;
  const tokenUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/login/oauth/access_token` : void 0;
  const userProfileUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/api/v3/user` : void 0;
  const callbackUrl = `${config2.baseUrl}/${providerId}/handler/frame`;
  const provider = new GithubAuthProvider({
    clientId,
    clientSecret,
    callbackUrl,
    tokenUrl,
    userProfileUrl,
    authorizationUrl
  });
  return OAuthProvider.fromConfig(config2, provider, {
    disableRefresh: true,
    persistScopes: true,
    providerId,
    tokenIssuer
  });
}

class GitlabAuthProvider {
  static transformPassportProfile(rawProfile) {
    const profile = {
      id: rawProfile.id,
      username: rawProfile.username,
      provider: rawProfile.provider,
      displayName: rawProfile.displayName
    };
    if (rawProfile.emails && rawProfile.emails.length > 0) {
      profile.emails = rawProfile.emails;
    }
    if (rawProfile.avatarUrl) {
      profile.photos = [{value: rawProfile.avatarUrl}];
    }
    return profile;
  }
  static transformOAuthResponse(accessToken, rawProfile, params = {}) {
    const passportProfile = GitlabAuthProvider.transformPassportProfile(rawProfile);
    const profile = makeProfileInfo(passportProfile, params.id_token);
    const providerInfo = {
      accessToken,
      scope: params.scope,
      expiresInSeconds: params.expires_in,
      idToken: params.id_token
    };
    let id = passportProfile.id;
    if (profile.email) {
      id = profile.email.split("@")[0];
    }
    if (params.expires_in) {
      providerInfo.expiresInSeconds = params.expires_in;
    }
    if (params.id_token) {
      providerInfo.idToken = params.id_token;
    }
    return {
      providerInfo,
      profile,
      backstageIdentity: {
        id
      }
    };
  }
  constructor(options) {
    this._strategy = new passportGitlab2.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      baseURL: options.baseUrl
    }, (accessToken, _, params, rawProfile, done) => {
      const oauthResponse = GitlabAuthProvider.transformOAuthResponse(accessToken, rawProfile, params);
      done(void 0, oauthResponse);
    });
  }
  async start(req, options) {
    return await executeRedirectStrategy(req, this._strategy, options);
  }
  async handler(req) {
    return await executeFrameHandlerStrategy(req, this._strategy);
  }
}
function createGitlabProvider(config2, _, envConfig, _logger, tokenIssuer) {
  const providerId = "gitlab";
  const clientId = envConfig.getString("clientId");
  const clientSecret = envConfig.getString("clientSecret");
  const audience = envConfig.getString("audience");
  const baseUrl = audience || "https://gitlab.com";
  const callbackUrl = `${config2.baseUrl}/${providerId}/handler/frame`;
  const provider = new GitlabAuthProvider({
    clientId,
    clientSecret,
    callbackUrl,
    baseUrl
  });
  return OAuthProvider.fromConfig(config2, provider, {
    disableRefresh: true,
    providerId,
    tokenIssuer
  });
}

class GoogleAuthProvider {
  constructor(options) {
    this._strategy = new passportGoogleOauth20.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, rawProfile, done) => {
      const profile = makeProfileInfo(rawProfile, params.id_token);
      done(void 0, {
        providerInfo: {
          idToken: params.id_token,
          accessToken,
          scope: params.scope,
          expiresInSeconds: params.expires_in
        },
        profile
      }, {
        refreshToken
      });
    });
  }
  async start(req, options) {
    const providerOptions = {
      ...options,
      accessType: "offline",
      prompt: "consent"
    };
    return await executeRedirectStrategy(req, this._strategy, providerOptions);
  }
  async handler(req) {
    const {response, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.populateIdentity(response),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(refreshToken, scope) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, refreshToken, scope);
    const profile = await executeFetchUserProfileStrategy(this._strategy, accessToken, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Google profile contained no email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
function createGoogleProvider(config2, _, envConfig, _logger, tokenIssuer) {
  const providerId = "google";
  const clientId = envConfig.getString("clientId");
  const clientSecret = envConfig.getString("clientSecret");
  const callbackUrl = `${config2.baseUrl}/${providerId}/handler/frame`;
  const provider = new GoogleAuthProvider({
    clientId,
    clientSecret,
    callbackUrl
  });
  return OAuthProvider.fromConfig(config2, provider, {
    disableRefresh: false,
    providerId,
    tokenIssuer
  });
}

class OAuth2AuthProvider {
  constructor(options) {
    this._strategy = new OAuth2Strategy.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      authorizationURL: options.authorizationUrl,
      tokenURL: options.tokenUrl,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, rawProfile, done) => {
      const profile = makeProfileInfo(rawProfile, params.id_token);
      done(void 0, {
        providerInfo: {
          idToken: params.id_token,
          accessToken,
          scope: params.scope,
          expiresInSeconds: params.expires_in
        },
        profile
      }, {
        refreshToken
      });
    });
  }
  async start(req, options) {
    const providerOptions = {
      ...options,
      accessType: "offline",
      prompt: "consent"
    };
    return await executeRedirectStrategy(req, this._strategy, providerOptions);
  }
  async handler(req) {
    const {response, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.populateIdentity(response),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(refreshToken, scope) {
    const refreshTokenResponse = await executeRefreshTokenStrategy(this._strategy, refreshToken, scope);
    const {
      accessToken,
      params,
      refreshToken: updatedRefreshToken
    } = refreshTokenResponse;
    const profile = await executeFetchUserProfileStrategy(this._strategy, accessToken, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        refreshToken: updatedRefreshToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Profile does not contain a profile");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
function createOAuth2Provider(config2, _, envConfig, _logger, tokenIssuer) {
  const providerId = "oauth2";
  const clientId = envConfig.getString("clientId");
  const clientSecret = envConfig.getString("clientSecret");
  const callbackUrl = `${config2.baseUrl}/${providerId}/handler/frame`;
  const authorizationUrl = envConfig.getString("authorizationUrl");
  const tokenUrl = envConfig.getString("tokenUrl");
  const provider = new OAuth2AuthProvider({
    clientId,
    clientSecret,
    callbackUrl,
    authorizationUrl,
    tokenUrl
  });
  return OAuthProvider.fromConfig(config2, provider, {
    disableRefresh: false,
    providerId,
    tokenIssuer
  });
}

class OktaAuthProvider {
  constructor(options) {
    this._store = {
      store(_req, cb) {
        cb(null, null);
      },
      verify(_req, _state, cb) {
        cb(null, true);
      }
    };
    this._strategy = new passportOktaOauth.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      audience: options.audience,
      passReqToCallback: false,
      store: this._store,
      response_type: "code"
    }, (accessToken, refreshToken, params, rawProfile, done) => {
      const profile = makeProfileInfo(rawProfile, params.id_token);
      done(void 0, {
        providerInfo: {
          idToken: params.id_token,
          accessToken,
          scope: params.scope,
          expiresInSeconds: params.expires_in
        },
        profile
      }, {
        refreshToken
      });
    });
  }
  async start(req, options) {
    const providerOptions = {
      ...options,
      accessType: "offline",
      prompt: "consent"
    };
    return await executeRedirectStrategy(req, this._strategy, providerOptions);
  }
  async handler(req) {
    const {response, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.populateIdentity(response),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(refreshToken, scope) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, refreshToken, scope);
    const profile = await executeFetchUserProfileStrategy(this._strategy, accessToken, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Okta profile contained no email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
function createOktaProvider(config2, _, envConfig, _logger, tokenIssuer) {
  const providerId = "okta";
  const clientId = envConfig.getString("clientId");
  const clientSecret = envConfig.getString("clientSecret");
  const audience = envConfig.getString("audience");
  const callbackUrl = `${config2.baseUrl}/${providerId}/handler/frame`;
  const provider = new OktaAuthProvider({
    audience,
    clientId,
    clientSecret,
    callbackUrl
  });
  return OAuthProvider.fromConfig(config2, provider, {
    disableRefresh: false,
    providerId,
    tokenIssuer
  });
}

class SamlAuthProvider {
  constructor(options) {
    this.tokenIssuer = options.tokenIssuer;
    this.strategy = new passportSaml.Strategy({...options}, (profile, done) => {
      done(void 0, {
        userId: profile.ID,
        profile: {
          email: profile.email,
          displayName: profile.displayName
        }
      });
    });
  }
  async start(req, res) {
    const {url} = await executeRedirectStrategy(req, this.strategy, {});
    res.redirect(url);
  }
  async frameHandler(req, res) {
    try {
      const {
        response: {userId, profile}
      } = await executeFrameHandlerStrategy(req, this.strategy);
      const id = userId;
      const idToken = await this.tokenIssuer.issueToken({
        claims: {sub: id}
      });
      return postMessageResponse(res, "http://localhost:3000", {
        type: "authorization_response",
        response: {
          providerInfo: {},
          profile,
          backstageIdentity: {id, idToken}
        }
      });
    } catch (error) {
      return postMessageResponse(res, "http://localhost:3000", {
        type: "authorization_response",
        error: {
          name: error.name,
          message: error.message
        }
      });
    }
  }
  async logout(_req, res) {
    res.send("noop");
  }
  identifyEnv() {
    return void 0;
  }
}
function createSamlProvider(_authProviderConfig, _env, envConfig, _logger, tokenIssuer) {
  const entryPoint = envConfig.getString("entryPoint");
  const issuer = envConfig.getString("issuer");
  const opts = {
    entryPoint,
    issuer,
    path: "/auth/saml/handler/frame",
    tokenIssuer
  };
  return new SamlAuthProvider(opts);
}

class Auth0Strategy extends OAuth2Strategy__default {
  constructor(options, verify) {
    const optionsWithURLs = {
      ...options,
      authorizationURL: `https://${options.domain}/authorize`,
      tokenURL: `https://${options.domain}/oauth/token`,
      userInfoURL: `https://${options.domain}/userinfo`,
      apiUrl: `https://${options.domain}/api`
    };
    super(optionsWithURLs, verify);
  }
}

class Auth0AuthProvider {
  constructor(options) {
    this._strategy = new Auth0Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      domain: options.domain,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, rawProfile, done) => {
      const profile = makeProfileInfo(rawProfile, params.id_token);
      done(void 0, {
        providerInfo: {
          idToken: params.id_token,
          accessToken,
          scope: params.scope,
          expiresInSeconds: params.expires_in
        },
        profile
      }, {
        refreshToken
      });
    });
  }
  async start(req, options) {
    const providerOptions = {
      ...options,
      accessType: "offline",
      prompt: "consent"
    };
    return await executeRedirectStrategy(req, this._strategy, providerOptions);
  }
  async handler(req) {
    const {response, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.populateIdentity(response),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(refreshToken, scope) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, refreshToken, scope);
    const profile = await executeFetchUserProfileStrategy(this._strategy, accessToken, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Profile does not contain a profile");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
function createAuth0Provider(config2, _, envConfig, _logger, tokenIssuer) {
  const providerId = "auth0";
  const clientId = envConfig.getString("clientId");
  const clientSecret = envConfig.getString("clientSecret");
  const domain = envConfig.getString("domain");
  const callbackUrl = `${config2.baseUrl}/${providerId}/handler/frame`;
  const provider = new Auth0AuthProvider({
    clientId,
    clientSecret,
    callbackUrl,
    domain
  });
  return OAuthProvider.fromConfig(config2, provider, {
    disableRefresh: true,
    providerId,
    tokenIssuer
  });
}

class MicrosoftAuthProvider {
  static transformAuthResponse(accessToken, params, rawProfile, photoURL) {
    let passportProfile = rawProfile;
    passportProfile = {
      ...passportProfile,
      photos: [{value: photoURL}]
    };
    const profile = makeProfileInfo(passportProfile, params.id_token);
    const providerInfo = {
      idToken: params.id_token,
      accessToken,
      scope: params.scope,
      expiresInSeconds: params.expires_in
    };
    return {
      providerInfo,
      profile
    };
  }
  constructor(options) {
    this._strategy = new passportMicrosoft.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      authorizationURL: options.authorizationUrl,
      tokenURL: options.tokenUrl,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, rawProfile, done) => {
      this.getUserPhoto(accessToken).then((photoURL) => {
        const authResponse = MicrosoftAuthProvider.transformAuthResponse(accessToken, params, rawProfile, photoURL);
        done(void 0, authResponse, {refreshToken});
      }).catch((error) => {
        throw new Error(`Error processing auth response: ${error}`);
      });
    });
  }
  async start(req, options) {
    return await executeRedirectStrategy(req, this._strategy, options);
  }
  async handler(req) {
    const {response, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.populateIdentity(response),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(refreshToken, scope) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, refreshToken, scope);
    const profile = await executeFetchUserProfileStrategy(this._strategy, accessToken, params.id_token);
    const photo = await this.getUserPhoto(accessToken);
    if (photo) {
      profile.picture = photo;
    }
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  getUserPhoto(accessToken) {
    return new Promise((resolve) => {
      got2.get("https://graph.microsoft.com/v1.0/me/photos/48x48/$value", {
        encoding: "binary",
        responseType: "buffer",
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      }).then((photoData) => {
        const photoURL = `data:image/jpeg;base64,${Buffer.from(photoData.body).toString("base64")}`;
        resolve(photoURL);
      }).catch((error) => {
        console.log(`Could not retrieve user profile photo from Microsoft Graph API: ${error}`);
        resolve();
      });
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Microsoft profile contained no email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
function createMicrosoftProvider(config2, _, envConfig, _logger, tokenIssuer) {
  const providerId = "microsoft";
  const clientId = envConfig.getString("clientId");
  const clientSecret = envConfig.getString("clientSecret");
  const tenantID = envConfig.getString("tenantId");
  const callbackUrl = `${config2.baseUrl}/${providerId}/handler/frame`;
  const authorizationUrl = `https://login.microsoftonline.com/${tenantID}/oauth2/v2.0/authorize`;
  const tokenUrl = `https://login.microsoftonline.com/${tenantID}/oauth2/v2.0/token`;
  const provider = new MicrosoftAuthProvider({
    clientId,
    clientSecret,
    callbackUrl,
    authorizationUrl,
    tokenUrl
  });
  return OAuthProvider.fromConfig(config2, provider, {
    disableRefresh: false,
    providerId,
    tokenIssuer
  });
}

class EnvironmentHandler {
  constructor(providerId, providers, envIdentifier) {
    this.providerId = providerId;
    this.providers = providers;
    this.envIdentifier = envIdentifier;
  }
  getProviderForEnv(req, res) {
    const env = this.envIdentifier(req);
    if (!env) {
      throw new backendCommon.InputError(`Must specify 'env' query to select environment`);
    }
    if (this.providers.hasOwnProperty(env)) {
      return this.providers[env];
    }
    res.status(404).send(`Missing configuration.
<br>
<br>
For this flow to work you need to supply a valid configuration for the "${env}" environment of the "${this.providerId}" provider.`);
    return void 0;
  }
  async start(req, res) {
    const provider = this.getProviderForEnv(req, res);
    await (provider == null ? void 0 : provider.start(req, res));
  }
  async frameHandler(req, res) {
    const provider = this.getProviderForEnv(req, res);
    await (provider == null ? void 0 : provider.frameHandler(req, res));
  }
  async refresh(req, res) {
    var _a;
    const provider = this.getProviderForEnv(req, res);
    await ((_a = provider == null ? void 0 : provider.refresh) == null ? void 0 : _a.call(provider, req, res));
  }
  async logout(req, res) {
    var _a;
    const provider = this.getProviderForEnv(req, res);
    await ((_a = provider == null ? void 0 : provider.logout) == null ? void 0 : _a.call(provider, req, res));
  }
}

const factories = {
  google: createGoogleProvider,
  github: createGithubProvider,
  gitlab: createGitlabProvider,
  saml: createSamlProvider,
  okta: createOktaProvider,
  auth0: createAuth0Provider,
  microsoft: createMicrosoftProvider,
  oauth2: createOAuth2Provider
};
const createAuthProviderRouter = (providerId, globalConfig, providerConfig, logger, issuer) => {
  const factory = factories[providerId];
  if (!factory) {
    throw Error(`No auth provider available for '${providerId}'`);
  }
  const router = Router();
  const envs = providerConfig.keys();
  const envProviders = {};
  let envIdentifier;
  for (const env of envs) {
    const envConfig = providerConfig.getConfig(env);
    const provider = factory(globalConfig, env, envConfig, logger, issuer);
    if (provider) {
      envProviders[env] = provider;
      envIdentifier = provider.identifyEnv;
    }
  }
  if (typeof envIdentifier === "undefined") {
    throw Error(`No envIdentifier provided for '${providerId}'`);
  }
  const handler = new EnvironmentHandler(providerId, envProviders, envIdentifier);
  router.get("/start", handler.start.bind(handler));
  router.get("/handler/frame", handler.frameHandler.bind(handler));
  router.post("/handler/frame", handler.frameHandler.bind(handler));
  if (handler.logout) {
    router.post("/logout", handler.logout.bind(handler));
  }
  if (handler.refresh) {
    router.get("/refresh", handler.refresh.bind(handler));
  }
  return router;
};

function createOidcRouter(options) {
  const {baseUrl, tokenIssuer} = options;
  const router = Router();
  const config = {
    issuer: baseUrl,
    token_endpoint: `${baseUrl}/v1/token`,
    userinfo_endpoint: `${baseUrl}/v1/userinfo`,
    jwks_uri: `${baseUrl}/v1/certs`,
    response_types_supported: ["id_token"],
    subject_types_supported: ["public"],
    id_token_signing_alg_values_supported: ["RS256"],
    scopes_supported: ["openid"],
    token_endpoint_auth_methods_supported: [],
    claims_supported: ["sub"],
    grant_types_supported: []
  };
  router.get("/.well-known/openid-configuration", (_req, res) => {
    res.json(config);
  });
  router.get("/.well-known/jwks.json", async (_req, res) => {
    const {keys} = await tokenIssuer.listPublicKeys();
    res.json({keys});
  });
  router.get("/v1/token", (_req, res) => {
    res.status(501).send("Not Implemented");
  });
  router.get("/v1/userinfo", (_req, res) => {
    res.status(501).send("Not Implemented");
  });
  return router;
}

const MS_IN_S = 1e3;
class TokenFactory {
  constructor(options) {
    this.issuer = options.issuer;
    this.logger = options.logger;
    this.keyStore = options.keyStore;
    this.keyDurationSeconds = options.keyDurationSeconds;
  }
  async issueToken(params) {
    const key = await this.getKey();
    const iss = this.issuer;
    const sub = params.claims.sub;
    const aud = "backstage";
    const iat = Math.floor(Date.now() / MS_IN_S);
    const exp = iat + this.keyDurationSeconds * MS_IN_S;
    this.logger.info(`Issuing token for ${sub}`);
    return jose.JWS.sign({iss, sub, aud, iat, exp}, key, {
      alg: key.alg,
      kid: key.kid
    });
  }
  async listPublicKeys() {
    const {items: keys} = await this.keyStore.listKeys();
    const validKeys = [];
    const expiredKeys = [];
    for (const key of keys) {
      const expireAt = key.createdAt.add(3 * this.keyDurationSeconds, "s");
      if (expireAt.isBefore()) {
        expiredKeys.push(key);
      } else {
        validKeys.push(key);
      }
    }
    if (expiredKeys.length > 0) {
      const kids = expiredKeys.map(({key}) => key.kid);
      this.logger.info(`Removing expired signing keys, '${kids.join("', '")}'`);
      this.keyStore.removeKeys(kids).catch((error) => {
        this.logger.error(`Failed to remove expired keys, ${error}`);
      });
    }
    return {keys: validKeys.map(({key}) => key)};
  }
  async getKey() {
    var _a;
    if (this.privateKeyPromise) {
      if ((_a = this.keyExpiry) == null ? void 0 : _a.isAfter()) {
        return this.privateKeyPromise;
      }
      this.logger.info(`Signing key has expired, generating new key`);
      delete this.privateKeyPromise;
    }
    this.keyExpiry = moment2__default().add(this.keyDurationSeconds, "seconds");
    const promise = (async () => {
      const key = await jose.JWK.generate("EC", "P-256", {
        use: "sig",
        kid: uuid.v4(),
        alg: "ES256"
      });
      this.logger.info(`Created new signing key ${key.kid}`);
      await this.keyStore.addKey(key.toJWK(false));
      return key;
    })();
    this.privateKeyPromise = promise;
    try {
      await promise;
    } catch (error) {
      this.logger.error(`Failed to generate new signing key, ${error}`);
      delete this.keyExpiry;
      delete this.privateKeyPromise;
    }
    return promise;
  }
}

const migrationsDir = backendCommon.resolvePackagePath("@backstage/plugin-auth-backend", "migrations");
const TABLE = "signing_keys";
class DatabaseKeyStore {
  static async create(options) {
    const {database} = options;
    await database.migrate.latest({
      directory: migrationsDir
    });
    return new DatabaseKeyStore(options);
  }
  constructor(options) {
    this.database = options.database;
  }
  async addKey(key) {
    await this.database(TABLE).insert({
      kid: key.kid,
      key: JSON.stringify(key)
    });
  }
  async listKeys() {
    const rows = await this.database(TABLE).select();
    return {
      items: rows.map((row) => ({
        key: JSON.parse(row.key),
        createdAt: moment2.utc(row.created_at)
      }))
    };
  }
  async removeKeys(kids) {
    await this.database(TABLE).delete().whereIn("kid", kids);
  }
}

async function createRouter(options) {
  const router = Router();
  const logger = options.logger.child({plugin: "auth"});
  const appUrl = options.config.getString("app.baseUrl");
  const backendUrl = options.config.getString("backend.baseUrl");
  const authUrl = `${backendUrl}/auth`;
  const keyDurationSeconds = 3600;
  const keyStore = await DatabaseKeyStore.create({
    database: options.database
  });
  const tokenIssuer = new TokenFactory({
    issuer: authUrl,
    keyStore,
    keyDurationSeconds,
    logger: logger.child({component: "token-factory"})
  });
  router.use(cookieParser());
  router.use(express2.urlencoded({extended: false}));
  router.use(express2.json());
  const providersConfig = options.config.getConfig("auth.providers");
  const providers2 = providersConfig.keys();
  for (const providerId of providers2) {
    logger.info(`Configuring provider, ${providerId}`);
    try {
      const providerConfig = providersConfig.getConfig(providerId);
      const providerRouter = createAuthProviderRouter(providerId, {baseUrl: authUrl, appUrl}, providerConfig, logger, tokenIssuer);
      router.use(`/${providerId}`, providerRouter);
    } catch (e) {
      if (process.env.NODE_ENV !== "development") {
        throw new Error(`Failed to initialize ${providerId} auth provider, ${e.message}`);
      }
      logger.warn(`Skipping ${providerId} auth provider, ${e.message}`);
    }
  }
  router.use(createOidcRouter({
    tokenIssuer,
    baseUrl: authUrl
  }));
  return router;
}

exports.createRouter = createRouter;
