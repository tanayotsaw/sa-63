'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var cliCommon = require('@backstage/cli-common');
var configLoader = require('@backstage/config-loader');
var knex2 = _interopDefault(require('knex'));
var lodash = require('lodash');
var winston = require('winston');
var stream = require('stream');
var morgan2 = _interopDefault(require('morgan'));
var compression2 = _interopDefault(require('compression'));
var cors2 = _interopDefault(require('cors'));
var express2 = _interopDefault(require('express'));
var helmet2 = _interopDefault(require('helmet'));
var stoppable2 = _interopDefault(require('stoppable'));
var http = require('http');
var https = require('https');
var prom = _interopDefault(require('prom-client'));
var promBundle = _interopDefault(require('express-prom-bundle'));
var Router = _interopDefault(require('express-promise-router'));
var path = require('path');

async function loadBackendConfig() {
  const paths = cliCommon.findPaths(__dirname);
  const configs = await configLoader.loadConfig({
    env: process.env.NODE_ENV,
    rootPaths: [paths.targetRoot, paths.targetDir],
    shouldReadSecrets: true
  });
  return configs;
}

function mergeDatabaseConfig(config, ...overrides) {
  return lodash.merge(config, ...overrides);
}

function createPgDatabaseClient(dbConfig, overrides) {
  const knexConfig = buildPgDatabaseConfig(dbConfig, overrides);
  const database = knex2(knexConfig);
  return database;
}
function buildPgDatabaseConfig(dbConfig, overrides) {
  return mergeDatabaseConfig(dbConfig.get(), {
    connection: getPgConnectionConfig(dbConfig, !!overrides),
    useNullAsDefault: true
  }, overrides);
}
function getPgConnectionConfig(dbConfig, parseConnectionString) {
  const connection = dbConfig.get("connection");
  const isConnectionString = typeof connection === "string" || connection instanceof String;
  const autoParse = typeof parseConnectionString !== "boolean";
  const shouldParseConnectionString = autoParse ? isConnectionString : parseConnectionString && isConnectionString;
  return shouldParseConnectionString ? parsePgConnectionString(connection) : connection;
}
function parsePgConnectionString(connectionString) {
  const parse = requirePgConnectionString();
  return parse(connectionString);
}
function requirePgConnectionString() {
  try {
    return require("pg-connection-string").parse;
  } catch (e) {
    const message = `Postgres: Install 'pg-connection-string'`;
    throw new Error(`${message}
${e.message}`);
  }
}

function createSqliteDatabaseClient(dbConfig, overrides) {
  const knexConfig = buildSqliteDatabaseConfig(dbConfig, overrides);
  const database = knex2(knexConfig);
  database.client.pool.on("createSuccess", (_eventId, resource) => {
    resource.run("PRAGMA foreign_keys = ON", () => {
    });
  });
  return database;
}
function buildSqliteDatabaseConfig(dbConfig, overrides) {
  return mergeDatabaseConfig(dbConfig.get(), {
    useNullAsDefault: true
  }, overrides);
}

function createDatabaseClient(dbConfig, overrides) {
  const client = dbConfig.getString("client");
  if (client === "pg") {
    return createPgDatabaseClient(dbConfig, overrides);
  } else if (client === "sqlite3") {
    return createSqliteDatabaseClient(dbConfig);
  }
  return knex2(mergeDatabaseConfig(dbConfig.get(), overrides));
}
const createDatabase = createDatabaseClient;

class CustomErrorBase extends Error {
  constructor(message, cause) {
    let fullMessage = message;
    if (cause) {
      if (fullMessage) {
        fullMessage += `; caused by ${cause}`;
      } else {
        fullMessage = `caused by ${cause}`;
      }
    }
    super(fullMessage);
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.cause = cause;
  }
}
class InputError extends CustomErrorBase {
}
class AuthenticationError extends CustomErrorBase {
}
class NotAllowedError extends CustomErrorBase {
}
class NotFoundError extends CustomErrorBase {
}
class ConflictError extends CustomErrorBase {
}

const coloredTemplate = (info) => {
  const {timestamp, level, message, plugin, service} = info;
  const colorizer = winston.format.colorize();
  const prefix = plugin || service;
  const timestampColor = colorizer.colorize("timestamp", timestamp);
  const prefixColor = colorizer.colorize("prefix", prefix);
  return `${timestampColor} ${prefixColor} ${level} ${message}`;
};
const coloredFormat = winston.format.combine(winston.format.timestamp(), winston.format.colorize({
  colors: {timestamp: "dim", prefix: "blue"}
}), winston.format.printf(coloredTemplate));

let rootLogger = winston.createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: process.env.NODE_ENV === "production" ? winston.format.json() : coloredFormat,
  defaultMeta: {service: "backstage"},
  transports: [
    new winston.transports.Console({
      silent: process.env.JEST_WORKER_ID !== void 0 && !process.env.LOG_LEVEL
    })
  ]
});
function getRootLogger() {
  return rootLogger;
}
function setRootLogger(newLogger) {
  rootLogger = newLogger;
}

function getVoidLogger() {
  return winston.createLogger({
    transports: [new winston.transports.Stream({stream: new stream.PassThrough()})]
  });
}

function errorHandler(options = {}) {
  var _a;
  const showStackTraces = (_a = options.showStackTraces) != null ? _a : process.env.NODE_ENV === "development";
  const logger = (options.logger || getRootLogger()).child({
    type: "errorHandler"
  });
  return (error, _request, response, next) => {
    if (response.headersSent) {
      next(error);
      return;
    }
    const status = getStatusCode(error);
    const message = showStackTraces ? error.stack : error.message;
    if (logger && status >= 500) {
      logger.error(error);
    }
    response.status(status).send(message);
  };
}
function getStatusCode(error) {
  const knownStatusCodeFields = ["statusCode", "status"];
  for (const field of knownStatusCodeFields) {
    const statusCode = error[field];
    if (typeof statusCode === "number" && (statusCode | 0) === statusCode && statusCode >= 100 && statusCode <= 599) {
      return statusCode;
    }
  }
  switch (error.name) {
    case InputError.name:
      return 400;
    case AuthenticationError.name:
      return 401;
    case NotAllowedError.name:
      return 403;
    case NotFoundError.name:
      return 404;
    case ConflictError.name:
      return 409;
  }
  return 500;
}

function notFoundHandler() {
  return (_request, response, _next) => {
    response.status(404).send();
  };
}

function requestLoggingHandler(logger) {
  const actualLogger = (logger || getRootLogger()).child({
    type: "incomingRequest"
  });
  return morgan2("combined", {
    stream: {
      write(message) {
        actualLogger.info(message);
      }
    }
  });
}

async function statusCheckHandler(options = {}) {
  const statusCheck = options.statusCheck ? options.statusCheck : () => Promise.resolve({status: "ok"});
  return async (_request, response, next) => {
    try {
      const status = await statusCheck();
      response.status(200).header("").send(status);
    } catch (err) {
      next(err);
    }
  };
}

function findAllAncestors(_module) {
  const ancestors = new Array();
  const parentIds = new Set();
  function add(id, m) {
    if (parentIds.has(id)) {
      return;
    }
    parentIds.add(id);
    ancestors.push(m);
    for (const parentId of m.parents) {
      const parent = require.cache[parentId];
      if (parent) {
        add(parentId, parent);
      }
    }
  }
  add(_module.id, _module);
  return ancestors;
}
function useHotCleanup(_module, cancelEffect) {
  var _a;
  if (_module.hot) {
    const ancestors = findAllAncestors(_module);
    let cancelled = false;
    const handler = () => {
      if (!cancelled) {
        cancelled = true;
        cancelEffect();
      }
    };
    for (const m of ancestors) {
      (_a = m.hot) == null ? void 0 : _a.addDisposeHandler(handler);
    }
  }
}
const CURRENT_HOT_MEMOIZE_INDEX_KEY = "backstage.io/hmr-memoize-key";
function useHotMemoize(_module, valueFactory) {
  var _a, _b, _c;
  if (!_module.hot) {
    return valueFactory();
  }
  if (!((_a = _module.hot.data) == null ? void 0 : _a[CURRENT_HOT_MEMOIZE_INDEX_KEY])) {
    for (const ancestor of findAllAncestors(_module)) {
      (_b = ancestor.hot) == null ? void 0 : _b.addDisposeHandler((data) => {
        data[CURRENT_HOT_MEMOIZE_INDEX_KEY] = 1;
      });
    }
    _module.hot.data = {
      ..._module.hot.data,
      [CURRENT_HOT_MEMOIZE_INDEX_KEY]: 1
    };
  }
  const index = _module.hot.data[CURRENT_HOT_MEMOIZE_INDEX_KEY]++;
  const value = (_c = _module.hot.data[index]) != null ? _c : valueFactory();
  _module.hot.addDisposeHandler((data) => {
    data[index] = value;
  });
  return value;
}

function readBaseOptions(config2) {
  if (typeof config2.get("listen") === "string") {
    const {host, port} = parseListenAddress(config2.getString("listen"));
    return removeUnknown({
      listenPort: port,
      listenHost: host
    });
  }
  return removeUnknown({
    listenPort: config2.getOptionalNumber("listen.port"),
    listenHost: config2.getOptionalString("listen.host"),
    baseUrl: config2.getOptionalString("baseUrl")
  });
}
function readCorsOptions(config2) {
  const cc = config2.getOptionalConfig("cors");
  if (!cc) {
    return void 0;
  }
  return removeUnknown({
    origin: getOptionalStringOrStrings(cc, "origin"),
    methods: getOptionalStringOrStrings(cc, "methods"),
    allowedHeaders: getOptionalStringOrStrings(cc, "allowedHeaders"),
    exposedHeaders: getOptionalStringOrStrings(cc, "exposedHeaders"),
    credentials: cc.getOptionalBoolean("credentials"),
    maxAge: cc.getOptionalNumber("maxAge"),
    preflightContinue: cc.getOptionalBoolean("preflightContinue"),
    optionsSuccessStatus: cc.getOptionalNumber("optionsSuccessStatus")
  });
}
function readHttpsSettings(config2) {
  const cc = config2.getOptionalConfig("https");
  if (!cc) {
    return void 0;
  }
  const certificateConfig = cc.get("certificate");
  const cfg = {
    certificate: certificateConfig
  };
  return removeUnknown(cfg);
}
function getOptionalStringOrStrings(config2, key) {
  const value = config2.getOptional(key);
  if (value === void 0 || typeof value === "string" || isStringArray(value)) {
    return value;
  }
  throw new Error(`Expected string or array of strings, got ${typeof value}`);
}
function isStringArray(value) {
  if (!Array.isArray(value)) {
    return false;
  }
  for (const v of value) {
    if (typeof v !== "string") {
      return false;
    }
  }
  return true;
}
function removeUnknown(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== void 0));
}
function parseListenAddress(value) {
  const parts = value.split(":");
  if (parts.length === 1) {
    return {port: parseInt(parts[0], 10)};
  }
  if (parts.length === 2) {
    return {host: parts[0], port: parseInt(parts[1], 10)};
  }
  throw new Error(`Unable to parse listen address ${value}, expected <port> or <host>:<port>`);
}

function createHttpServer(app, logger) {
  logger == null ? void 0 : logger.info("Initializing http server");
  return http.createServer(app);
}
function createHttpsServer(app, httpsSettings, logger) {
  logger == null ? void 0 : logger.info("Initializing https server");
  const credentials = {
    key: "",
    cert: ""
  };
  const signingOptions = httpsSettings == null ? void 0 : httpsSettings.certificate;
  if ((signingOptions == null ? void 0 : signingOptions.algorithm) !== void 0) {
    logger == null ? void 0 : logger.info("Generating self-signed certificate with attributes");
    const certificateAttributes = Object.entries(signingOptions.attributes).map(([name, value]) => ({name, value}));
    const signatures = require("selfsigned").generate(certificateAttributes, {
      algorithm: signingOptions == null ? void 0 : signingOptions.algorithm,
      keySize: (signingOptions == null ? void 0 : signingOptions.size) || 2048,
      days: (signingOptions == null ? void 0 : signingOptions.days) || 30
    });
    logger == null ? void 0 : logger.info("Bootstrapping self-signed certificate");
    credentials.key = signatures.private;
    credentials.cert = signatures.cert;
  } else {
    logger == null ? void 0 : logger.info("Bootstrapping cert from config");
    credentials.key = signingOptions == null ? void 0 : signingOptions.key;
    credentials.cert = signingOptions == null ? void 0 : signingOptions.cert;
  }
  if (credentials.key === "" || credentials.cert === "") {
    throw new Error("Invalid credentials");
  }
  return https.createServer(credentials, app);
}

function metricsHandler() {
  prom.register.clear();
  return promBundle({
    includeMethod: true,
    includePath: true,
    normalizePath: [["^/([^/]*)/.*", "/$1"]],
    promClient: {collectDefaultMetrics: {}}
  });
}

const DEFAULT_PORT = 7e3;
const DEFAULT_HOST = "";
class ServiceBuilderImpl {
  constructor(moduleRef) {
    this.enableMetrics = true;
    this.routers = [];
    this.module = moduleRef;
  }
  loadConfig(config3) {
    const backendConfig = config3.getOptionalConfig("backend");
    if (!backendConfig) {
      return this;
    }
    const baseOptions = readBaseOptions(backendConfig);
    if (baseOptions.listenPort) {
      this.port = baseOptions.listenPort;
    }
    if (baseOptions.listenHost) {
      this.host = baseOptions.listenHost;
    }
    const corsOptions = readCorsOptions(backendConfig);
    if (corsOptions) {
      this.corsOptions = corsOptions;
    }
    const httpsSettings = readHttpsSettings(backendConfig);
    if (httpsSettings) {
      this.httpsSettings = httpsSettings;
    }
    this.enableMetrics = backendConfig.getOptionalBoolean("metrics") !== false;
    return this;
  }
  setPort(port) {
    this.port = port;
    return this;
  }
  setHost(host) {
    this.host = host;
    return this;
  }
  setLogger(logger) {
    this.logger = logger;
    return this;
  }
  setHttpsSettings(settings) {
    this.httpsSettings = settings;
    return this;
  }
  enableCors(options) {
    this.corsOptions = options;
    return this;
  }
  addRouter(root, router) {
    this.routers.push([root, router]);
    return this;
  }
  start() {
    const app = express2();
    const {
      port,
      host,
      logger,
      corsOptions,
      httpsSettings
    } = this.getOptions();
    app.use(helmet2());
    if (corsOptions) {
      app.use(cors2(corsOptions));
    }
    app.use(compression2());
    if (this.enableMetrics) {
      app.use(metricsHandler());
    }
    app.use(requestLoggingHandler());
    for (const [root, route] of this.routers) {
      app.use(root, route);
    }
    app.use(notFoundHandler());
    app.use(errorHandler());
    return new Promise((resolve, reject) => {
      app.on("error", (e) => {
        logger.error(`Failed to start up on port ${port}, ${e}`);
        reject(e);
      });
      const server = httpsSettings ? createHttpsServer(app, httpsSettings, logger) : createHttpServer(app, logger);
      const stoppableServer = stoppable2(server.listen(port, host, () => {
        logger.info(`Listening on ${host}:${port}`);
      }), 0);
      useHotCleanup(this.module, () => stoppableServer.stop((e) => {
        if (e)
          console.error(e);
      }));
      resolve(stoppableServer);
    });
  }
  getOptions() {
    var _a, _b, _c;
    return {
      port: (_a = this.port) != null ? _a : DEFAULT_PORT,
      host: (_b = this.host) != null ? _b : DEFAULT_HOST,
      logger: (_c = this.logger) != null ? _c : getRootLogger(),
      corsOptions: this.corsOptions,
      httpsSettings: this.httpsSettings
    };
  }
}

function createServiceBuilder(_module) {
  return new ServiceBuilderImpl(_module);
}

async function createStatusCheckRouter(options) {
  const router = Router();
  const {path = "/healthcheck", statusCheck} = options;
  router.use(path, await statusCheckHandler({statusCheck}));
  router.use(errorHandler());
  return router;
}

function resolvePackagePath(name, ...paths) {
  const req = typeof __non_webpack_require__ === "undefined" ? require : __non_webpack_require__;
  return path.resolve(req.resolve(`${name}/package.json`), "..", ...paths);
}

exports.AuthenticationError = AuthenticationError;
exports.ConflictError = ConflictError;
exports.InputError = InputError;
exports.NotAllowedError = NotAllowedError;
exports.NotFoundError = NotFoundError;
exports.createDatabase = createDatabase;
exports.createDatabaseClient = createDatabaseClient;
exports.createServiceBuilder = createServiceBuilder;
exports.createStatusCheckRouter = createStatusCheckRouter;
exports.errorHandler = errorHandler;
exports.getRootLogger = getRootLogger;
exports.getVoidLogger = getVoidLogger;
exports.loadBackendConfig = loadBackendConfig;
exports.notFoundHandler = notFoundHandler;
exports.requestLoggingHandler = requestLoggingHandler;
exports.resolvePackagePath = resolvePackagePath;
exports.setRootLogger = setRootLogger;
exports.statusCheckHandler = statusCheckHandler;
exports.useHotCleanup = useHotCleanup;
exports.useHotMemoize = useHotMemoize;
