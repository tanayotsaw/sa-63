/// <reference types="node" />
/// <reference types="webpack-env" />
import { AppConfig, Config, ConfigReader } from '@backstage/config';
import knex from 'knex';
import { Logger } from 'winston';
import express, { ErrorRequestHandler, RequestHandler, Router } from 'express';
import cors from 'cors';
import { Server } from 'http';

/**
 * Load configuration for a Backend
 */
declare function loadBackendConfig(): Promise<AppConfig[]>;

/**
 * Creates a knex database connection
 *
 * @param dbConfig The database config
 * @param overrides Additional options to merge with the config
 */
declare function createDatabaseClient(dbConfig: Config, overrides?: Partial<knex.Config>): knex<any, unknown[]>;
/**
 * Alias for createDatabaseClient
 * @deprecated Use createDatabaseClient instead
 */
declare const createDatabase: typeof createDatabaseClient;

declare class CustomErrorBase extends Error {
    readonly cause?: Error;
    constructor(message?: string, cause?: Error);
}
/**
 * The given inputs are malformed and cannot be processed.
 */
declare class InputError extends CustomErrorBase {
}
/**
 * The request requires authentication, which was not properly supplied.
 */
declare class AuthenticationError extends CustomErrorBase {
}
/**
 * The authenticated caller is not allowed to perform this request.
 */
declare class NotAllowedError extends CustomErrorBase {
}
/**
 * The requested resource could not be found.
 *
 * Note that this error usually is used to indicate that an entity with a given
 * ID does not exist, rather than signalling that an entire route is missing.
 */
declare class NotFoundError extends CustomErrorBase {
}
/**
 * The request could not complete due to a conflict in the current state of the
 * resource.
 */
declare class ConflictError extends CustomErrorBase {
}

declare function getRootLogger(): Logger;
declare function setRootLogger(newLogger: Logger): void;

/**
 * A logger that just throws away all messages.
 */
declare function getVoidLogger(): Logger;

declare type ErrorHandlerOptions = {
    /**
     * Whether error response bodies should show error stack traces or not.
     *
     * If not specified, by default shows stack traces only in development mode.
     */
    showStackTraces?: boolean;
    /**
     * Logger instance to log any 5xx errors.
     *
     * If not specified, the root logger will be used.
     */
    logger?: Logger;
};
/**
 * Express middleware to handle errors during request processing.
 *
 * This is commonly the very last middleware in the chain.
 *
 * Its primary purpose is not to do translation of business logic exceptions,
 * but rather to be a gobal catch-all for uncaught "fatal" errors that are
 * expected to result in a 500 error. However, it also does handle some common
 * error types (such as http-error exceptions) and returns the enclosed status
 * code accordingly.
 *
 * @returns An Express error request handler
 */
declare function errorHandler(options?: ErrorHandlerOptions): ErrorRequestHandler;

/**
 * Express middleware to handle requests for missing routes.
 *
 * Should be used as the very last handler in the chain, as it unconditionally
 * returns a 404 status.
 *
 * @returns An Express request handler
 */
declare function notFoundHandler(): RequestHandler;

/**
 * Logs incoming requests.
 *
 * @param logger An optional logger to use. If not specified, the root logger will be used.
 * @returns An Express request handler
 */
declare function requestLoggingHandler(logger?: Logger): RequestHandler;

declare type StatusCheck = () => Promise<any>;
interface StatusCheckHandlerOptions {
    /**
     * Optional status function which returns a message.
     */
    statusCheck?: StatusCheck;
}
/**
 * Express middleware for status checks.
 *
 * This is commonly used to implement healthcheck and readiness routes.
 *
 * @param options An optional configuration object.
 * @returns An Express error request handler
 */
declare function statusCheckHandler(options?: StatusCheckHandlerOptions): Promise<RequestHandler>;

declare type HttpsSettings = {
    certificate: CertificateSigningOptions | CertificateReferenceOptions;
};
declare type CertificateReferenceOptions = {
    key: string;
    cert: string;
};
declare type CertificateSigningOptions = {
    algorithm: string;
    size?: number;
    days?: number;
    attributes?: CertificateAttributes;
};
declare type CertificateAttributes = {
    commonName?: string;
};

declare type ServiceBuilder = {
    /**
     * Sets the service parameters based on configuration.
     *
     * @param config The configuration to read
     */
    loadConfig(config: ConfigReader): ServiceBuilder;
    /**
     * Sets the port to listen on.
     *
     * If no port is specified, the service will first look for an environment
     * variable named PORT and use that if present, otherwise it picks a default
     * port (7000).
     *
     * @param port The port to listen on
     */
    setPort(port: number): ServiceBuilder;
    /**
     * Sets the host to listen on.
     *
     * '' is express default, which listens to all interfaces.
     *
     * @param host The host to listen on
     */
    setHost(host: string): ServiceBuilder;
    /**
     * Sets the logger to use for service-specific logging.
     *
     * If no logger is given, the default root logger is used.
     *
     * @param logger A winston logger
     */
    setLogger(logger: Logger): ServiceBuilder;
    /**
     * Enables CORS handling using the given settings.
     *
     * If this method is not called, the resulting service will not have any
     * built in CORS handling.
     *
     * @param options Standard CORS options
     */
    enableCors(options: cors.CorsOptions): ServiceBuilder;
    /**
     * Configure self-signed certificate generation options.
     *
     * If this method is not called, the resulting service will use sensible defaults
     *
     * @param options Standard certificate options
     */
    setHttpsSettings(settings: HttpsSettings): ServiceBuilder;
    /**
     * Adds a router (similar to the express .use call) to the service.
     *
     * @param root The root URL to bind to (e.g. "/api/function1")
     * @param router An express router
     */
    addRouter(root: string, router: Router | RequestHandler): ServiceBuilder;
    /**
     * Starts the server using the given settings.
     */
    start(): Promise<Server>;
};

declare class ServiceBuilderImpl implements ServiceBuilder {
    private port;
    private host;
    private logger;
    private corsOptions;
    private httpsSettings;
    private enableMetrics;
    private routers;
    private module;
    constructor(moduleRef: NodeModule);
    loadConfig(config: ConfigReader): ServiceBuilder;
    setPort(port: number): ServiceBuilder;
    setHost(host: string): ServiceBuilder;
    setLogger(logger: Logger): ServiceBuilder;
    setHttpsSettings(settings: HttpsSettings): ServiceBuilder;
    enableCors(options: cors.CorsOptions): ServiceBuilder;
    addRouter(root: string, router: Router): ServiceBuilder;
    start(): Promise<Server>;
    private getOptions;
}

/**
 * Creates a new service builder.
 */
declare function createServiceBuilder(_module: NodeModule): ServiceBuilderImpl;

interface StatusCheckRouterOptions {
    logger: Logger;
    path?: string;
    statusCheck?: StatusCheck;
}
declare function createStatusCheckRouter(options: StatusCheckRouterOptions): Promise<express.Router>;

/**
 * Resolve a path relative to the root of a package directory.
 * Additional path arguments are resolved relative to the package dir.
 *
 * This is particularly useful when you want to access assets shipped with
 * your backend plugin package. When doing so, do not forget to include the assets
 * in your published package by adding them to `files` in your `package.json`.
 */
declare function resolvePackagePath(name: string, ...paths: string[]): string;



/**
 * useHotCleanup allows cleanup of ongoing effects when a module is
 * hot-reloaded during development. The cleanup function will be called
 * whenever the module itself or any of its parent modules is hot-reloaded.
 *
 * Useful for cleaning intervals, timers, requests etc
 *
 * @example
 * ```ts
 * const intervalId = setInterval(doStuff, 1000);
 * useHotCleanup(module, () => clearInterval(intervalId));
 * ```
 * @param _module Reference to the current module where you invoke the fn
 * @param cancelEffect Fn that cleans up the ongoing effects
 */
declare function useHotCleanup(_module: NodeModule, cancelEffect: () => void): void;
/**
 * Memoizes a generated value across hot-module reloads. This is useful for
 * stateful parts of the backend, e.g. to retain a database.
 *
 * @example
 * ```ts
 * const db = useHotMemoize(module, () => createDB(dbParams));
 * ```
 *
 * @warning Don't use inside conditionals or loops,
 * same rules as for hooks apply (https://reactjs.org/docs/hooks-rules.html)
 *
 * @param _module Reference to the current module where you invoke the fn
 * @param valueFactory Fn that returns the value you want to memoize
 */
declare function useHotMemoize<T>(_module: NodeModule, valueFactory: () => T): T;

export { AuthenticationError, ConflictError, ErrorHandlerOptions, InputError, NotAllowedError, NotFoundError, ServiceBuilder, StatusCheck, StatusCheckHandlerOptions, createDatabase, createDatabaseClient, createServiceBuilder, createStatusCheckRouter, errorHandler, getRootLogger, getVoidLogger, loadBackendConfig, notFoundHandler, requestLoggingHandler, resolvePackagePath, setRootLogger, statusCheckHandler, useHotCleanup, useHotMemoize };
