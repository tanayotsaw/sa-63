'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var index = require('./index-8e863345.js');
var fs = _interopDefault(require('fs-extra'));
var webpack2 = _interopDefault(require('webpack'));
var path2 = require('path');
var path2__default = _interopDefault(path2);
var ForkTsCheckerWebpackPlugin = _interopDefault(require('fork-ts-checker-webpack-plugin'));
var HtmlWebpackPlugin = _interopDefault(require('html-webpack-plugin'));
var ModuleScopePlugin2 = _interopDefault(require('react-dev-utils/ModuleScopePlugin'));
var StartServerPlugin = _interopDefault(require('start-server-webpack-plugin'));
var nodeExternals = _interopDefault(require('webpack-node-externals'));
var MiniCssExtractPlugin = _interopDefault(require('mini-css-extract-plugin'));
var svgrTemplate = require('./svgrTemplate-2930b0e1.js');
var run = require('./run-76e92ad7.js');

const optimization = (options) => {
  const {isDev} = options;
  return {
    minimize: !isDev,
    runtimeChunk: "single",
    splitChunks: {
      automaticNameDelimiter: "-",
      cacheGroups: {
        default: false,
        packages: {
          chunks: "initial",
          test: /[\\/]node_modules[\\/]/,
          name(module) {
            const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
            return packageName.replace("@", "");
          },
          filename: isDev ? "module-[name].js" : "static/module-[name].[chunkhash:8].js",
          priority: 10,
          minSize: 1e5,
          minChunks: 1,
          maxAsyncRequests: Infinity,
          maxInitialRequests: Infinity
        },
        vendor: {
          chunks: "initial",
          test: /[\\/]node_modules[\\/]/,
          name: "vendor",
          priority: 5,
          enforce: true
        }
      }
    }
  };
};

const transforms = (options) => {
  const {isDev} = options;
  const extraTransforms = isDev ? ["react-hot-loader"] : [];
  const loaders = [
    {
      test: /\.(tsx?)$/,
      exclude: /node_modules/,
      loader: require.resolve("@sucrase/webpack-loader"),
      options: {
        transforms: ["typescript", "jsx", ...extraTransforms],
        production: !isDev
      }
    },
    {
      test: /\.(jsx?|mjs)$/,
      exclude: /node_modules/,
      loader: require.resolve("@sucrase/webpack-loader"),
      options: {
        transforms: ["jsx", ...extraTransforms],
        production: !isDev
      }
    },
    {
      test: [/\.icon\.svg$/],
      use: [
        {
          loader: require.resolve("@sucrase/webpack-loader"),
          options: {
            transforms: ["jsx", ...extraTransforms],
            production: !isDev
          }
        },
        {
          loader: require.resolve("@svgr/webpack"),
          options: {babel: false, template: svgrTemplate.svgrTemplate}
        }
      ]
    },
    {
      test: [
        /\.bmp$/,
        /\.gif$/,
        /\.jpe?g$/,
        /\.png$/,
        /\.frag/,
        {test: /\.svg/, not: [/\.icon\.svg/]},
        /\.xml/
      ],
      loader: require.resolve("url-loader"),
      options: {
        limit: 1e4,
        name: "static/[name].[hash:8].[ext]"
      }
    },
    {
      test: /\.ya?ml$/,
      use: require.resolve("yml-loader")
    },
    {
      include: /\.(md)$/,
      use: require.resolve("raw-loader")
    },
    {
      test: /\.css$/i,
      use: [
        isDev ? require.resolve("style-loader") : MiniCssExtractPlugin.loader,
        {
          loader: require.resolve("css-loader"),
          options: {
            sourceMap: true
          }
        }
      ]
    }
  ];
  const plugins = new Array();
  if (isDev) {
    plugins.push(new webpack2.HotModuleReplacementPlugin());
  } else {
    plugins.push(new MiniCssExtractPlugin({
      filename: "static/[name].[contenthash:8].css",
      chunkFilename: "static/[name].[id].[contenthash:8].css"
    }));
  }
  return {loaders, plugins};
};

function resolveBaseUrl(config2) {
  const baseUrl = config2.getString("app.baseUrl");
  try {
    return new URL(baseUrl);
  } catch (error) {
    throw new Error(`Invalid app.baseUrl, ${error}`);
  }
}
async function readBuildInfo() {
  const timestamp = Date.now();
  let commit = "unknown";
  try {
    commit = await run.runPlain("git", "rev-parse", "HEAD");
  } catch (error) {
    console.warn(`WARNING: Failed to read git commit, ${error}`);
  }
  let gitVersion = "unknown";
  try {
    gitVersion = await run.runPlain("git", "describe", "--always");
  } catch (error) {
    console.warn(`WARNING: Failed to describe git version, ${error}`);
  }
  const {version: packageVersion} = await fs.readJson(index.paths.resolveTarget("package.json"));
  return {
    cliVersion: index.version,
    gitVersion,
    packageVersion,
    timestamp,
    commit
  };
}
async function createConfig(paths3, options) {
  const {checksEnabled, isDev} = options;
  const {plugins, loaders} = transforms(options);
  const baseUrl = options.config.getString("app.baseUrl");
  const validBaseUrl = new URL(baseUrl);
  if (checksEnabled) {
    plugins.push(new ForkTsCheckerWebpackPlugin({
      tsconfig: paths3.targetTsConfig,
      eslint: true,
      eslintOptions: {
        parserOptions: {
          project: paths3.targetTsConfig,
          tsconfigRootDir: paths3.targetPath
        }
      },
      reportFiles: ["**", "!**/__tests__/**", "!**/?(*.)(spec|test).*"]
    }));
  }
  plugins.push(new webpack2.EnvironmentPlugin({
    APP_CONFIG: options.appConfigs
  }));
  plugins.push(new HtmlWebpackPlugin({
    template: paths3.targetHtml,
    templateParameters: {
      publicPath: validBaseUrl.pathname.replace(/\/$/, ""),
      app: {
        title: options.config.getString("app.title"),
        baseUrl: validBaseUrl.href
      }
    }
  }));
  const buildInfo = await readBuildInfo();
  plugins.push(new webpack2.DefinePlugin({
    "process.env.BUILD_INFO": JSON.stringify(buildInfo)
  }));
  return {
    mode: isDev ? "development" : "production",
    profile: false,
    node: {
      module: "empty",
      dgram: "empty",
      dns: "mock",
      fs: "empty",
      http2: "empty",
      net: "empty",
      tls: "empty",
      child_process: "empty"
    },
    optimization: optimization(options),
    bail: false,
    performance: {
      hints: false
    },
    devtool: isDev ? "cheap-module-eval-source-map" : "source-map",
    context: paths3.targetPath,
    entry: [require.resolve("react-hot-loader/patch"), paths3.targetEntry],
    resolve: {
      extensions: [".ts", ".tsx", ".mjs", ".js", ".jsx"],
      mainFields: ["browser", "module", "main"],
      plugins: [
        new ModuleScopePlugin2([paths3.targetSrc, paths3.targetDev], [paths3.targetPackageJson])
      ],
      alias: {
        "react-dom": "@hot-loader/react-dom"
      }
    },
    module: {
      rules: loaders
    },
    output: {
      path: paths3.targetDist,
      publicPath: validBaseUrl.pathname,
      filename: isDev ? "[name].js" : "static/[name].[hash:8].js",
      chunkFilename: isDev ? "[name].chunk.js" : "static/[name].[chunkhash:8].chunk.js"
    },
    plugins
  };
}
async function createBackendConfig(paths3, options) {
  const {checksEnabled, isDev} = options;
  const {loaders} = transforms(options);
  const LernaProject = require("@lerna/project");
  const project = new LernaProject(index.paths.targetDir);
  const packages = await project.getPackages();
  const localPackageNames = packages.map((p) => p.name);
  const moduleDirs = packages.map((p) => path2.resolve(p.location, "node_modules"));
  return {
    mode: isDev ? "development" : "production",
    profile: false,
    ...isDev ? {
      watch: true,
      watchOptions: {
        ignored: [/node_modules\/(?!\@backstage)/]
      }
    } : {},
    externals: [
      nodeExternals({
        modulesDir: paths3.rootNodeModules,
        additionalModuleDirs: moduleDirs,
        allowlist: ["webpack/hot/poll?100", ...localPackageNames]
      })
    ],
    target: "node",
    node: {
      __dirname: true,
      __filename: true,
      global: true
    },
    bail: false,
    performance: {
      hints: false
    },
    devtool: isDev ? "cheap-module-eval-source-map" : "source-map",
    context: paths3.targetPath,
    entry: [
      "webpack/hot/poll?100",
      paths3.targetRunFile ? paths3.targetRunFile : paths3.targetEntry
    ],
    resolve: {
      extensions: [".ts", ".tsx", ".mjs", ".js", ".jsx"],
      mainFields: ["browser", "module", "main"],
      modules: [paths3.rootNodeModules, ...moduleDirs],
      plugins: [
        new ModuleScopePlugin2([paths3.targetSrc, paths3.targetDev], [paths3.targetPackageJson])
      ],
      alias: {
        "react-dom": "@hot-loader/react-dom"
      }
    },
    module: {
      rules: loaders
    },
    output: {
      path: paths3.targetDist,
      filename: isDev ? "[name].js" : "[name].[hash:8].js",
      chunkFilename: isDev ? "[name].chunk.js" : "[name].[chunkhash:8].chunk.js",
      ...isDev ? {
        devtoolModuleFilenameTemplate: "file:///[absolute-resource-path]"
      } : {}
    },
    plugins: [
      new StartServerPlugin({
        name: "main.js",
        nodeArgs: options.inspectEnabled ? ["--inspect"] : void 0
      }),
      new webpack2.HotModuleReplacementPlugin(),
      ...checksEnabled ? [
        new ForkTsCheckerWebpackPlugin({
          tsconfig: paths3.targetTsConfig,
          eslint: true,
          eslintOptions: {
            parserOptions: {
              project: paths3.targetTsConfig,
              tsconfigRootDir: paths3.targetPath
            }
          },
          reportFiles: ["**", "!**/__tests__/**", "!**/?(*.)(spec|test).*"]
        })
      ] : []
    ]
  };
}

function resolveBundlingPaths(options) {
  const {entry} = options;
  const resolveTargetModule = (path) => {
    for (const ext of ["mjs", "js", "ts", "tsx", "jsx"]) {
      const filePath = index.paths.resolveTarget(`${path}.${ext}`);
      if (fs.pathExistsSync(filePath)) {
        return filePath;
      }
    }
    return index.paths.resolveTarget(`${path}.js`);
  };
  let targetPublic = void 0;
  let targetHtml = index.paths.resolveTarget("public/index.html");
  if (fs.pathExistsSync(targetHtml)) {
    targetPublic = index.paths.resolveTarget("public");
  } else {
    targetHtml = index.paths.resolveTarget(`${entry}.html`);
    if (!fs.pathExistsSync(targetHtml)) {
      targetHtml = index.paths.resolveOwn("templates/serve_index.html");
    }
  }
  const targetRunFile = index.paths.resolveTarget("src/run.ts");
  const runFileExists = fs.pathExistsSync(targetRunFile);
  return {
    targetHtml,
    targetPublic,
    targetPath: index.paths.resolveTarget("."),
    targetRunFile: runFileExists ? targetRunFile : void 0,
    targetDist: index.paths.resolveTarget("dist"),
    targetAssets: index.paths.resolveTarget("assets"),
    targetSrc: index.paths.resolveTarget("src"),
    targetDev: index.paths.resolveTarget("dev"),
    targetEntry: resolveTargetModule(entry),
    targetTsConfig: index.paths.resolveTargetRoot("tsconfig.json"),
    targetPackageJson: index.paths.resolveTarget("package.json"),
    rootNodeModules: index.paths.resolveTargetRoot("node_modules"),
    root: index.paths.targetRoot
  };
}

exports.createBackendConfig = createBackendConfig;
exports.createConfig = createConfig;
exports.resolveBaseUrl = resolveBaseUrl;
exports.resolveBundlingPaths = resolveBundlingPaths;
